\hypertarget{documentation_documentation_intro}{}\section{Introduction}\label{documentation_documentation_intro}
This section covers the basic procedures for how to generate documentation for the Open\-S\-E\-A project. This includes the types of documentation, which applications to use for documentation generation, and how to generate the documentation.

Accurate documentation is critical for this project. Even more critical than having code completely bug free. The users must trust the program, and to do that, they will want to thoroughly understand how the program operates. To that end, every application in Open\-S\-E\-A has three documentation manuals associated with it.
\begin{DoxyEnumerate}
\item Developer Manual
\item Theory Manual
\item User Manual
\end{DoxyEnumerate}

Each manual has a specific purpose. You can read more in the following sections. Beyond these three manuals, there is also some documentation that is common to all three manuals. This is documented separately and then referenced for inclusion in all three manuals.

The Open\-S\-E\-A project uses two completely different applications for generating documentation.
\begin{DoxyEnumerate}
\item Doxygen
\begin{DoxyItemize}
\item Used to document source code.
\end{DoxyItemize}
\item Open Office / Libre Office
\begin{DoxyItemize}
\item Used to document user manual and theory manual.
\end{DoxyItemize}
\end{DoxyEnumerate}

These two systems then get combined together with the Qt help project system to generate a single coherent set of documentation.\hypertarget{documentation_documentation_twosyst}{}\subsection{Why Two Systems}\label{documentation_documentation_twosyst}
Why create two documentation systems? Doesn't it cause extra confusion? Short answer\-: Yes, but the extra effort is worth the reliability and efficiency of features. This is a case of once again appealing to the primary developer roles on the Open\-S\-E\-A project\-: software engineers, and marine engineers.

The code is best documented with Doxygen. This allows the authors to write code documention directly in the source files when they write the code. That ensures the documentation is directly avaiable, maintains consistency with the code, and saves on many hours of writing and formating separate documentation.

But there is another side of documentation\-: the user. The common user for Open\-S\-E\-A has an advanced technical background and was trained to suspect all programs are wrong until thoroughly validated and documented. Thus is it is important to have extensive documentation on theory and use of the program. This builds user confidence.

The development environment of Open Office / Libre Office is ideally suited to the user and theory manauls. These manuals need to read more like a scientific paper. Simple things like spelling and typos can quickly undermine user confidence. Open Office / Libre Office includes all the authoring tools necessary to automatically check for these items. It also includes automatic referencing and a bibliography. All necessary for the scientific background of this program.

Finally, it is still important to present a consistent appearance for easier user interface. The Qt help system can combine the two authoring systems together into a single, final set of user documentation with all the expected features of searches, an index, and table of contents.\hypertarget{documentation_documentation_manuals}{}\section{Documentation Manuals}\label{documentation_documentation_manuals}
There are three main documentation manuals. Each with their own style and purpose. And there is also commmon documentation that gets included in all three manuals.\hypertarget{documentation_documentation_developer}{}\subsection{Developer Manual}\label{documentation_documentation_developer}
The developer manual contains all the details of the software coding itself.
\begin{DoxyItemize}
\item Generated using doxygen.
\item The full A\-P\-I for the code.
\item Output is html files
\item Doxygen automatically generates the help project file.
\end{DoxyItemize}

The majority of the documentation is written in the source code files. Doxygen scans these source code files and generates a full code A\-P\-I from them. It also generates U\-M\-L style class diagrams and call diagrams. Beyond the code A\-P\-I, the developer documentation also includes anything the developers need to know for enhancing the code and adding to the Open\-S\-E\-A project (specifically adding to source code). For example, this whole section on how to create project documentation is in the Developer Documentation.

Any documentation not included as part os the source code is added under a separate file structure. Doxygen can scan through multiple folders to create a single document which includes A\-P\-I and supplemental documentation. Organize the file structure similar to the final documentation structure. Sub-\/pages go within a sub-\/folder. Each documentation page is a separate text file, with a .dox file extension. All files are plain text A\-S\-I\-I files.

\begin{DoxyNote}{Note}
Each documentation page is a separate text file, with a .dox file extension. All files are plain text A\-S\-I\-I files. File formatting is Markdown
\end{DoxyNote}
Files are formatted using Markdown formating. This is specifically the version of Markdown supported by Doxygen. \href{http://www.stack.nl/~dimitri/doxygen/manual/markdown.html}{\tt Doxygen Markdown Support} Doxygen also supports \href{http://www.stack.nl/~dimitri/doxygen/manual/formulas.html}{\tt mathematical formulas}, using Latex. However, there should be very limited formulas included in the developer documentation.

Output from Doxygen should be html output, with the Qt .qhp file included. Write the Doxygen output to a completely separate folder from the original files. Keep the originals separated from the final output. This makes it easier to quickly revise the documentation.\hypertarget{documentation_documentation_theory}{}\subsection{Theory Manual}\label{documentation_documentation_theory}
The theory manual explains the math and science behind the Open\-S\-E\-A project.
\begin{DoxyItemize}
\item Generated using Open Office / Libre Office
\item The equations behind the program
\item More styled like a scientific paper
\item Output is html files, generated from Libre Office / Open Office
\end{DoxyItemize}

It does not reproduce an entire education on naval architecture and seakeeping theory. But within the science of seakeeping, there are many approaches and methods. The theory documentation should explicitely detail out the following things\-:


\begin{DoxyEnumerate}
\item Exactly what the equations were
\item Exactly what methods were used
\item Exactly what assumptions were made
\item Exactly what simplifications were made
\end{DoxyEnumerate}

Place the theory documentation in its own separate folder. Each documentation page should be a separate file. Organize the file structure similar to the final documentation structure. Sub-\/pages go within a sub-\/folder. The final Qt project file will specify the exact organization, so the file structure does not need to be 100\% perfect.

Files are formatted using Open Office / Libre Office. A file template is provided. This template must be used. It is absolutely critical that the styles are used within this template. {\bfseries Do not create your own styles or directly format anything.} This is because the final documentation replaces the formatting in the documentation with a reference to an external cascading style sheet (C\-S\-S) formatting. But the style names must remain the same. Otherwise the styles referenced in the documentation page do not match the formatting instructions in the C\-S\-S sheet.

Save the original files as .odt files. And then use Save\-As to publish the files as html files. Write the html files to a completely separate folder from the original files. Keep the originals separated from the final output. This makes it easier to quickly revise the documentation. The final .html files do not need to maintain the same folder structure as the originals. The Qt Project file handles that.\hypertarget{documentation_documentation_user}{}\subsection{User Manual}\label{documentation_documentation_user}
The user manual handles the nuts and bolts of how to actually operate the program. What command to enter for each step.
\begin{DoxyItemize}
\item Generated using Open Office / Libre Office
\item The instructions for operating the programs
\item Styled like a classic help file. Practical and simple
\item Output is html files, generated from Libre Office / Open Office
\end{DoxyItemize}

The user documentation covers all the operational instructions. This is where you explain the general process of how to operate the program. Explain the concepts and how the data is organized. Get down to the practical details. Even simple things like\-: what units are the inputs given in? Also include general concepts. Example\-: explain what a body is within the program. Also include any tutorials and worked examples in this user documentation.

Place the user documentation in its own separate folder. Each documentation page should be a separate file. Organize the file structure similar to the final documentation structure. Sub-\/pages go within a sub-\/folder. The final Qt project file will specify the exact organization, so the file structure does not need to be 100\% perfect.

Files are formatted using Open Office / Libre Office. A file template is provided. This template must be used. It is absolutely critical that the styles are used within this template. {\bfseries Do not create your own styles or directly format anything.} This is because the final documentation replaces the formatting in the documentation with a reference to an external cascading style sheet (C\-S\-S) formatting. But the style names must remain the same. Otherwise the styles referenced in the documentation page do not match the formatting instructions in the C\-S\-S sheet.

Save the original files as .odt files. And then use Save\-As to publish the files as html files. Write the html files to a completely separate folder from the original files. Keep the originals separated from the final output. This makes it easier to quickly revise the documentation. The final .html files do not need to maintain the same folder structure as the originals. The Qt Project file handles that.\hypertarget{documentation_documentation_common}{}\subsection{Common Documentation}\label{documentation_documentation_common}
Finally, there is some documentation that is common to every manual. This is included in its own separate folder and referenced by all three manauls.
\begin{DoxyItemize}
\item Generated using Open Office / Libre Office
\item Really basic, common information
\item Styled like a dictionary or other reference material.
\item Output is html files, generated from Libre Office / Open Office
\end{DoxyItemize}

The common documentation should be items like definitions for terms used in the program. Or common units of measurement for inputs and outputs. Really basic stuff.

\section*{Document Numbering System}

Every document in the document numbering system must have a unique identifier number associated with it. The subpage explains the document numbering system. All developers must respect it. (Or come up with a better system and help me implement it.)

\hyperlink{docnumbersys}{Documenation Numbering System}\hypertarget{documentation_documentation_combine}{}\section{Combining For Final Output}\label{documentation_documentation_combine}
You noticed that all manuals produce html output. This is the neutral medium that all the authoring tools publish to. We then use the Qt Help Project system to combine the html files into a single cohesive documentation file. Go through the following steps to publish the documentation.


\begin{DoxyEnumerate}
\item For each manual, create The \-\_\-\-Q\-\_\-t \-\_\-\-C\-\_\-ompressed \-\_\-\-H\-\_\-elp file (.qch) from the html files.

a. First create the help project configuration file (.qhp).

b. Then execute the following command (linux operating system) to compile the compressed help file. doc.\-qhp is the name of the configuration file and output.\-qch is the name of the output Qt compressed help file. \begin{DoxyVerb}qhelpgenerator doc.qhp -o output.qch
\end{DoxyVerb}

\end{DoxyEnumerate}


\begin{DoxyEnumerate}
\item Repeat this process for each manual. You should have three separate .qhp files when done.
\item Next create the final combined help collection file.

a. Create a collection configuration file (.qhcp)

b. Then execute the following command (linux operating system) to compile the final help collection file. mycollection.\-qhcp is the name of the configuration file and collection\-\_\-output.\-qhc is the name of the final compiled collection file. \begin{DoxyVerb}qcollectiongenerator mycollection.qhcp -o collection_output.qhc
\end{DoxyVerb}

\end{DoxyEnumerate}

See the sub sections below for details on what to enter for each configuration file and how it all goes together. You can also look at this tutorial online, which gives a great overview for the process.

\href{http://www.off-soft.net/en/develop/qt/qt1-8-2.html}{\tt How to Create Qt Help Files}

\subsection*{Help Projects}

\hyperlink{helpproject}{Qt Help Project}

\begin{TabularC}{2}
\hline
\rowcolor{lightgray}\PBS\centering {\bf File Type }&{\bf Commentary }\\\cline{1-2}
\PBS\centering .qch file &{\itshape Q} t {\itshape C} ompressed {\itshape H} elp files. H\-T\-M\-L documents are written in (including attached images and other information) to the S\-Q\-Lite3 database. Create qhelpgenerator command. \\\cline{1-2}
\PBS\centering .qhp file &{\itshape Q} t {\itshape H} elp {\itshape P} roject file. Configuration file that controls the generation of the qch file. Also controls the list of H\-T\-M\-L files to include. \\\cline{1-2}
\end{TabularC}


\subsection*{Help Collections}

\hyperlink{collection}{Qt Collection Files}

\begin{TabularC}{2}
\hline
\rowcolor{lightgray}\PBS\centering {\bf File Type }&{\bf Commentary }\\\cline{1-2}
\PBS\centering .qhc file &{\itshape Q} t {\itshape H} elp {\itshape C} ollection files. S\-Q\-Lite3 files are compiled into a database. Qhc includes file management and appearance of the help browser. Create qcollectiongenerator command. \\\cline{1-2}
\PBS\centering .qhcp file &{\itshape Q} t {\itshape H} elp {\itshape C} ollection \-\_\-\-P\-\_\-roject file. Configuration file that controls the generation of the qhc file. Specifies which .qch files to include. Here, Qt\-Assistant You can also customize some parts of the screen. \\\cline{1-2}
\end{TabularC}
\hypertarget{documentation_documentation_using}{}\section{Using the Documentation}\label{documentation_documentation_using}
So you went through all that and created a Qt help file. But how to actually open it? We open is using the program Qt Assistant. And as part of the program, we specify a command option that indiciates which help file to open. \begin{DoxyVerb}assistant -collectionfile mycollection.qhc
\end{DoxyVerb}


Where assistant is the linux command to start Qt Assistant. You can enter this into any terminal command line. And mycollection is the name of the compiled help collection file. This file should include all three manuals.

The Qt Assistant also has an A\-P\-I to call help pages from within the program you write. You can learn more at the subpages.

\hyperlink{assistant}{Qt Assistant}

\hyperlink{helpengine_api}{Qt Help Engine A\-P\-I} \hypertarget{docnumbersys}{}\section{Documenation Numbering System}\label{docnumbersys}
Every document page must have a document number associated with it. There are several reasons for this\-:
\begin{DoxyEnumerate}
\item There is a definite need to reference diagrams and equations across multiple pages
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item C\-S\-S formatting can not automatically create continuous numbers across multiple html pages.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item For project management purposes, we need a system to refer to the documentation internally. As the project grows, it will become very difficult to track all the documents without some system to reference them.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
The documentation numbering system is not strictly required for developer manuals, as this system is generated by Doxygen and largely self contained. But the user and theory manuals should all use the document numbering sytem. Numering of the developer documentation is still encouraged.
\end{DoxyNote}
\hypertarget{docnumbersys_docnumbersys_identifier}{}\subsection{Document Identifier}\label{docnumbersys_docnumbersys_identifier}
Every document has two identifiers that combine to create the complete document number. A complete document number looks like this\-: \begin{DoxyVerb}  T01-NNNN.NNNN.NNNN.NNNN
\end{DoxyVerb}


That identifies the document page. And within the document, individual equations and figures are numbered sequentially. So to reference equation 10 within a document, the full reference number would be\-: \begin{DoxyVerb}  T01-NNNN.NNNN.NNNN.NNNN-10
\end{DoxyVerb}


Now lets cover how to number the two idenfitiers.


\begin{DoxyEnumerate}
\item {\itshape T01} The first identifier (T01) is a reference to the manual that the document fits within. If the document is part of multiple manuals, just number it according to the first manual you use it in.
\item {\itshape N\-N\-N\-N.\-N\-N\-N\-N.\-N\-N\-N\-N.\-N\-N\-N\-N} The second identifier is a reference to the document number within that manual.
\end{DoxyEnumerate}

Each identifier system is explained in detail.\hypertarget{docnumbersys_docnumbersys_man}{}\subsubsection{Manual References}\label{docnumbersys_docnumbersys_man}
The first number is a reference to the manual that the document gets used in. This documentation system should continue to work for the entire duration of the Open\-S\-E\-A project. So the idenfitier needs to accommodate any future expansion or addition of future programs. The letter code on the identifier represents the type of manual.
\begin{DoxyEnumerate}
\item T = Theory manual
\item D = Developer manual
\item U = User manual
\item C = Common manual used in multiple manuals (Theory, Developer, and User manual).
\end{DoxyEnumerate}

The two digit number is a reference to the program being documented. T\-His number was specifically built to allow future additions of other programs. Every program, including minor utility programs, gets its own number.

\begin{TabularC}{5}
\hline
\rowcolor{lightgray}{\bf }&\PBS\centering {\bf Theory Manual }&\PBS\centering {\bf Developer Manual }&\PBS\centering {\bf User Manual }&\PBS\centering {\bf Common Manual }\\\cline{1-5}
G\-U\-I &\PBS\centering T01 &\PBS\centering D01 &\PBS\centering U01 &\PBS\centering C01 \\\cline{1-5}
o\-Batch &\PBS\centering T02 &\PBS\centering D02 &\PBS\centering U02 &\PBS\centering C02 \\\cline{1-5}
o\-Fourier &\PBS\centering T03 &\PBS\centering D03 &\PBS\centering U03 &\PBS\centering C03 \\\cline{1-5}
o\-Freq &\PBS\centering T04 &\PBS\centering D04 &\PBS\centering U04 &\PBS\centering C04 \\\cline{1-5}
ohydro &\PBS\centering T05 &\PBS\centering D05 &\PBS\centering U05 &\PBS\centering C05 \\\cline{1-5}
otime &\PBS\centering T06 &\PBS\centering D06 &\PBS\centering U06 &\PBS\centering C06 \\\cline{1-5}
Utility programs &\PBS\centering T10 &\PBS\centering D10 &\PBS\centering U10 &\PBS\centering C10 \\\cline{1-5}
... &\PBS\centering ... &\PBS\centering ... &\PBS\centering ... &\PBS\centering ... \\\cline{1-5}
Utility program N &\PBS\centering T\-N\-N &\PBS\centering D\-N\-N &\PBS\centering U\-N\-N &\PBS\centering C\-N\-N \\\cline{1-5}
\end{TabularC}
\hypertarget{docnumbersys_docnumbersys_docidentifier}{}\subsubsection{Document Number Reference}\label{docnumbersys_docnumbersys_docidentifier}
The second number is a set of recursive identifiers. Each idenfitier level represents another level of recursion in the document. For example, take the following document structure in the help system. Assume all documents are part of the G\-U\-I theory manual. \begin{DoxyVerb}  Ralph
  ----| James
  ----| ----| Johny
  ----| ----| ----| George 
\end{DoxyVerb}


Then each document would have the following number\-:

\begin{TabularC}{2}
\hline
\rowcolor{lightgray}{\bf Document }&{\bf Number }\\\cline{1-2}
Ralph &T01-\/0001 \\\cline{1-2}
James &T01-\/0001.\-0100 \\\cline{1-2}
John &T01-\/0001.\-0100.\-0020 \\\cline{1-2}
George &T01-\/0001.\-0100.\-0020.\-1000 \\\cline{1-2}
\end{TabularC}
$|$

Notice that at the top level, the identifier number only had four digits. Each sub-\/level increases the nubmer of digits assigned to the document number. Also notice that each level used a different numbering sytem. Sequential numbers do not need to be consecutive. You can skip numbers to leave room for other documents added later. You can use your own numbering system for each individual level. There are only the following rules for the numbering system.


\begin{DoxyEnumerate}
\item Each level must use a four digit number. Include zeros to fill in any digits you do not use.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Each level must be separated by a period (.).
\item Each sub-\/level must use the exact number from its parent level.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item You can recursively add levels without limit.
\item Every document must have a unique identifier. The full document number can not be repeated in any other document.
\end{DoxyEnumerate}\hypertarget{docnumbersys_why-system}{}\subsection{Why such a Detailed System}\label{docnumbersys_why-system}
The documentation system was detailed to allow flexibility and almost unlimited expansion. The Open\-S\-E\-A project will be a long duration project. There will be many changes along the way. The worst thing would be if we had to change the entire document numbering scheme half-\/way through the project. That would mean going back and editting every single piece of documentation. Thus the system was designed to allow maximum flexibility. \hypertarget{helpproject}{}\section{Qt Help Project}\label{helpproject}
\hypertarget{helpproject_helproject_reference}{}\subsection{Reference}\label{helpproject_helproject_reference}
Go to the following website for full details on how to use the Qt Help project.

\href{http://qt-project.org/doc/qt-4.8/qthelpproject.html}{\tt Qt Help Project}\hypertarget{helpproject_helpproject-intro}{}\subsection{Introduction}\label{helpproject_helpproject-intro}
A Qt help project collects all data necessary to generate a compressed help file. Along with the actual help data, like the table of contents, index keywords and help documents, it contains some extra information like a namespace to identify the help file. One help project stands for one documentation, e.\-g. the Qt Assistant manual. Qt Help Project File Format

The file format is X\-M\-L-\/based. For a better understanding of the format we'll discuss the following example\-: \begin{DoxyVerb}<?xml version="1.0" encoding="UTF-8"?>
<QtHelpProject version="1.0">
    <namespace>mycompany.com.myapplication.1.0</namespace>
    <virtualFolder>doc</virtualFolder>
    <customFilter name="My Application 1.0">
  <filterAttribute>myapp</filterAttribute>
  <filterAttribute>1.0</filterAttribute>
    </customFilter>
    <filterSection>
  <filterAttribute>myapp</filterAttribute>
  <filterAttribute>1.0</filterAttribute>
  <toc>
      <section title="My Application Manual" ref="index.html">
    <section title="Chapter 1" ref="doc.html#chapter1"/>
    <section title="Chapter 2" ref="doc.html#chapter2"/>
    <section title="Chapter 3" ref="doc.html#chapter3"/>
      </section>
  </toc>
  <keywords>
      <keyword name="foo" id="MyApplication::foo" ref="doc.html#foo"/>
      <keyword name="bar" ref="doc.html#bar"/>
      <keyword id="MyApplication::foobar" ref="doc.html#foobar"/>
  </keywords>
  <files>
      <file>classic.css</file>
      <file>*.html</file>
  </files>
    </filterSection>
</QtHelpProject>
\end{DoxyVerb}
\hypertarget{helpproject_helpproject-Namespace}{}\subsection{Namespace}\label{helpproject_helpproject-Namespace}
To enable the Q\-Help\-Engine to retrieve the proper documentation to a given link, every documentation set has to have a unique identifier. A unique identifier makes is also possible for the help collection to keep track of a documentation set without relying on its file name. The Qt help system uses a namespace as identifier which is defined by the mandatory namespace tags. In the example above, the namespace is \char`\"{}mycompany.\-com.\-myapplication.\-1.\-0\char`\"{}.\hypertarget{helpproject_hp_virtualfolder}{}\subsection{Virtual Folders}\label{helpproject_hp_virtualfolder}
Having a namespace for every documentation naturally means that the documentation sets are quite separated. From the help engines point of view this is beneficial, but from the documentors view it is often desirable to cross reference certain topic from one manual to another without having to specify absolute links. To solve this problem, the help system introduced the concept of virtual folders.

A virtual folder will become the root directory of all files referenced in a compressed help file. When two documentations share the same virtual folder, they can use relative paths when defining hyperlinks pointing to the other documentation. If a file is contained in both documentations or manuals, the one from the current manual has precedence over the other.

... $<$virtual\-Folder$>$doc$<$/virtual\-Folder$>$ ...

The above example specifies 'doc' as virtual folder. If another manual, e.\-g. for a small helper tool for 'My Application' specifies the same folder, it is sufficient to write 'doc.\-html\-::section1' to reference the first section in the 'My Application' manual.

The virtual folder tag is mandatory and the folder must not contain any '/'.\hypertarget{helpproject_hp_customfilters}{}\subsection{Custom Filters}\label{helpproject_hp_customfilters}
Next in the Qt help project file are the optional definitions of custom filters. A custom filter contains a list of filter attributes which will be used later to display only the documentation which has all those attributes assigned to. So, when setting the current filter in the Q\-Help\-Engine to \char`\"{}\-My 
\-Application 1.\-0\char`\"{} only the documentation which has \char`\"{}myapp\char`\"{} and \char`\"{}1.\-0\char`\"{} set as filter attributes will be shown.

... $<$custom\-Filter name=\char`\"{}\-My Application 1.\-0\char`\"{}$>$ $<$filter\-Attribute$>$myapp$<$/filter\-Attribute$>$ $<$filter\-Attribute$>$1.\-0$<$/filter\-Attribute$>$ $<$/custom\-Filter$>$ ...

It is possible to define any number of custom filters in a help project file. Important to know is, that the filter attributes have not to be specified in the same project file; they can be defined in any other help file. The definition of a filter attributes takes place by specifying them in a filter section.\hypertarget{helpproject_hep_filtersection}{}\subsection{Filter Section}\label{helpproject_hep_filtersection}
A filter section contains the actual documentation. One Qt help project file may contain more than one filter sections. Every filter section consists of four parts, the filter attributes section, the table of contents, the keywords and the files list. In theory all parts are optional but not specifying anything there will result in an empty documentation.\hypertarget{helpproject_helpproject_filteratts}{}\subsubsection{Filter Attributes}\label{helpproject_helpproject_filteratts}
Every filter section should have filter attributes assigned to it, to enable documentation filtering. If no filter attribute is defined, the documentation will only be shown if no filtering occurs, meaning the current custom filter in the Q\-Help\-Engine does not contain any filter attributes. \begin{DoxyVerb}...
<filterSection>
    <filterAttribute>myapp</filterAttribute>
    <filterAttribute>1.0</filterAttribute>
...
\end{DoxyVerb}


In this case, the filter attributes 'myapp' and '1.\-0' are assigned to the filter section, i.\-e. all contents specified in this section will only be shown if the current custom filter has 'myapp' or '1.\-0' or both as filter attributes.\hypertarget{helpproject_helpproject_tableofcontets}{}\subsubsection{Table of contents}\label{helpproject_helpproject_tableofcontets}
... $<$toc$>$ $<$section title=\char`\"{}\-My Application Manual\char`\"{} ref=\char`\"{}index.\-html\char`\"{}$>$ $<$section title=\char`\"{}\-Chapter 1\char`\"{} ref=\char`\"{}doc.\-html\#chapter1\char`\"{}$>$ $<$section title=\char`\"{}\-Chapter 2\char`\"{} ref=\char`\"{}doc.\-html\#chapter2\char`\"{}$>$ $<$section title=\char`\"{}\-Chapter 3\char`\"{} ref=\char`\"{}doc.\-html\#chapter3\char`\"{}$>$ $<$/section$>$ $<$/toc$>$ ...

One section tag represents one item in the table of contents. The sections can be nested to any degree, but from a users perspective it should not be more than four or five levels. A section is defined by its title and reference. The reference, like all file references in a Qt help project, are relative to the help project file itself. Note\-: The referenced files must be inside the same directory (or within a subdirectory) as the help project file. An absolute file path is not supported either.\hypertarget{helpproject_helpproject-kewords}{}\subsubsection{Keywords}\label{helpproject_helpproject-kewords}
... $<$keywords$>$ $<$keyword name=\char`\"{}foo\char`\"{} id=\char`\"{}\-My\-Application\-::foo\char`\"{} ref=\char`\"{}doc.\-html\#foo\char`\"{}$>$ $<$keyword name=\char`\"{}bar\char`\"{} ref=\char`\"{}doc.\-html\#bar\char`\"{}$>$ $<$keyword id=\char`\"{}\-My\-Application\-::foobar\char`\"{} ref=\char`\"{}doc.\-html\#foobar\char`\"{}$>$ $<$/keywords$>$ ...

The keyword section lists all keywords of this filter section. A keyword consists basically of a name and a file reference. If the attribute 'name' is used then the keyword specified there will appear in the visible index, i.\-e. it will be accessible through the Q\-Help\-Index\-Model. If 'id' is used, the keyword does not appear in the index and is only accessible via the links\-For\-Identifier() function of the Q\-Help\-Engine\-Core. 'name' and 'id' can be specified at the same time.\hypertarget{helpproject_helpproject_files}{}\subsubsection{Files}\label{helpproject_helpproject_files}
... $<$files$>$ $<$file$>$classic.\-css$<$/file$>$ $<$file$>$$\ast$.html$<$/file$>$ $<$/files$>$ ...

Finally, the actual documentation files have to be listed. Make sure that all files neccessary to display the help are mentioned, i.\-e. stylesheets or similar files need to be there as well. The files, like all file references in a Qt help project, are relative to the help project file itself. As the example shows, files (but not directories) can also be specified as patterns using wildcards. All listed files will be compressed and written to the Qt compressed help file. So, in the end, one single Qt help file contains all documentation files along with the contents and indices. Note\-: The referenced files must be inside the same directory (or within a subdirectory) as the help project file. An absolute file path is not supported either. \hypertarget{collection}{}\section{Qt Collection Files}\label{collection}
\hypertarget{collection_collection_reference}{}\subsection{Reference}\label{collection_collection_reference}
Go to the following page for full details of the Qt Collection Files

\href{*http://qt-project.org/doc/qt-4.8/qthelp-framework.html#creating-a-qt-help-collection}{\tt The Qt Help Framework}\hypertarget{collection_colection_overview}{}\subsection{Overview}\label{collection_colection_overview}
The Qt help system includes tools for generating and viewing Qt help files. In addition it provides classes for accessing help contents programatically to be able to integrate online help into Qt applications.

The actual help data, meaning the table of contents, index keywords or H\-T\-M\-L documents, is contained in Qt compressed help files. So, one such a help file represents usually one manual or documentation set. Since most products are more comprehensive and consist of a number of tools, one manual is rarely enough. Instead, more manuals which should be accessible at the same time, exist. Ideally, it should also be possible to reference certain points of interest of one manual to another. Therefore, the Qt help system operates on help collection files which include any number of compressed help files.

However, having collection files to merge many documentation sets may lead to some problems. For example, one index keyword may be defined in different documentations. So, when only seeing it in the index and activating it, you cannot be sure that the expected documentation will be shown. Therefore, the Qt help system offers the possibiltiy to filter the help contents after certain attributes. This requires however, that the attributes have been assigned to the help contents before the generation of the compressed help file.

As already mentioned, the Qt compressed help file contains all data, so there is no need any longer to ship all single H\-T\-M\-L files. Instead, only the compressed help file and optionally the collection file has to be distributed. The collection file is optional since any existing collection file, e.\-g. from an older release could be used.

So, in general, there are four files interacting with the help system, two used for generating Qt help and two meant for distribution\-:

\begin{TabularC}{3}
\hline
\rowcolor{lightgray}{\bf Name }&{\bf Extension }&{\bf Brief Description }\\\cline{1-3}
Qt Help Project &.qhp &The input file for the help generator consisting of the table of contents, indices and references to the actual documentation files ($\ast$.html); it also defines a unique namespace for the documentation. \\\cline{1-3}
Qt Compressed Help &.qch &The output file of the help generator. This binary file contains all information specified in the help project file along with all compressed documentation files. \\\cline{1-3}
Qt Help Collection Project &.qhcp &The input file for the help collection generator. It contains references to compressed help files which should be included in the collection; it also may contain other information for customizing Qt Assistant. \\\cline{1-3}
Qt Help Collection &.qhc &The output of the help collection generator. This is the file Q\-Help\-Engine operates on. It contains references to any number of compressed help files as well as additional information, such as custom filters. \\\cline{1-3}
\end{TabularC}
\hypertarget{collection_collection_gen}{}\subsection{Generating Qt Help}\label{collection_collection_gen}
Building help files for the Qt help system assumes that the H\-T\-M\-L documentation files already exist.

Once the H\-T\-M\-L documents are in place, a Qt Help Project file, with an extension of .qhp has to be created. After specifying all relevant information in this file, it needs to be compiled by calling\-:

qhelpgenerator doc.\-qhp -\/o doc.\-qch

The file 'doc.\-qch' contains then all H\-T\-M\-L files in compressed form along with the table of contents and index keywords. To test if the generated file is correct, open Qt Assistant and install the file via the Settings$|$\-Documentation page.

For the standard Qt source build, the .qhp file is generated and placed in the same directory as the H\-T\-M\-L pages.\hypertarget{collection_collection_create}{}\subsection{Creating a Qt Help Collection}\label{collection_collection_create}
The first step is to create a Qt Help Collection Project file. Since a Qt help collection stores primarily references to compressed help files, the project 'mycollection.\-qhcp' file looks unsurprisingly simple\-:

$<$?xml version=\char`\"{}1.\-0\char`\"{} encoding=\char`\"{}utf-\/8\char`\"{} ?$>$ $<$\-Q\-Help\-Collection\-Project version=\char`\"{}1.\-0\char`\"{}$>$ $<$doc\-Files$>$ $<$register$>$ $<$file$>$doc.\-qch$<$/file$>$ $<$/register$>$ $<$/doc\-Files$>$ $<$/\-Q\-Help\-Collection\-Project$>$

For actually creating the collection file call\-:

qcollectiongenerator mycollection.\-qhcp -\/o mycollection.\-qhc

Instead of running two tools, one for generating the compressed help and one for generating the collection file, it is also possible to just run the qcollectiongenerator tool with a slightly modified project file instructing the generator to create the compressed help first.

... $<$doc\-Files$>$ $<$generate$>$ $<$file$>$ $<$input$>$doc.\-qhp$<$/input$>$ $<$output$>$doc.\-qch$<$/output$>$ $<$/file$>$ $<$/generate$>$ $<$register$>$ $<$file$>$doc.\-qch$<$/file$>$ $<$/register$>$ $<$/doc\-Files$>$ ...

Of course, it is possible to specify more than one file in the 'generate' or 'register' section, so any number of compressed help files can be generated and registered in one go.\hypertarget{collection_collection_usinghelp}{}\subsection{Using Qt Help}\label{collection_collection_usinghelp}
Accessing the help contents can be done in two ways\-: Using Qt Assistant as documentation browser or using the Q\-Help\-Engine A\-P\-I for embedding the help contents directly in an application.\hypertarget{collection_collection_usingassistant}{}\subsection{Using Qt Assistant}\label{collection_collection_usingassistant}
Qt Assistant operates on a collection file which can be specified before start up. If no collection file is given, a default one will be created and used. In either case, it is possible to register any Qt compressed help file and access the help contents.

When using Assistant as the help browser for an application, it would be desirable that it can be customized to fit better to the application and doesn't look like an independent, standalone help browser. To achieve this, several additional properties can be set in an Qt help collection file, to change e.\-g. the title or application icon of Qt Assistant. For more information on this topic have a look at the Qt Assistant manual. \hypertarget{assistant}{}\section{Qt Assistant}\label{assistant}
\hypertarget{assistant_assisant_ref}{}\subsection{Reference Page}\label{assistant_assisant_ref}
Go to the following reference page for full documentation details about Qt Assistant.

\href{http://qt-project.org/doc/qt-4.8/assistant-custom-help-viewer.html}{\tt Using Qt Assistant as a Custom Help Viewer}\hypertarget{assistant_assisant_intro}{}\subsection{Using Qt Assistant as a Custom Help Viewer}\label{assistant_assisant_intro}
Using Qt Assistant as custom help viewer requires more than just being able to display custom documentation. It is equally important that the appearance of Qt Assistant can be customized so that it is seen as a application-\/specific help viewer rather than Qt Assistant. This is achieved by changing the window title or icon, as well as some application-\/specific menu texts and actions. The complete list of possible customizations can be found in the Creating a Custom Help Collection File section.

Another requirement of a custom help viewer is the ability to receive actions or commands from the application it provides help for. This is especially important when the application offers context sensitive help. When used in this way, the help viewer may need to change its contents depending on the state the application is currently in. This means that the application has to communicate the current state to the help viewer. The section about Using Qt Assistant Remotely explains how this can be done.

The Simple Text Viewer example uses the techniques described in this document to show how to use Qt Assistant as a custom help viewer for an application.

Warning\-: In order to ship Qt Assistant in your application, it is crucial that you include the sqlite plugin. For more information on how to include plugins in your application, refer to the deployment documentation. Qt Help Collection Files

The first important point to know about Qt Assistant is that it stores all settings related to its appearance and a list of installed documentation in a help collection file. This means, when starting Qt Assistant with different collection files, Qt Assistant may look totally different. This complete separation of settings makes it possible to deploy Qt Assistant as a custom help viewer for more than one application on one machine without risk of interference between different instances of Qt Assistant.

To apply a certain help collection to Qt Assistant, specify the respective collection file on the command line when starting it. For example\-: \begin{DoxyVerb}  assistant -collectionFile mycollection.qhc
\end{DoxyVerb}


However, storing all settings in one collection file raises some problems. The collection file is usually installed in the same directory as the application itself, or one of its subdirectories. Depending on the directory and the operating system, the user may not have any permissions to modify this file which would happen when the user settings are stored. Also, it may not even be possible to give the user write permissions; e.\-g., when the file is located on a read-\/only medium like a C\-D-\/\-R\-O\-M.

Even if it is possible to give everybody the right to store their settings in a globally available collection file, the settings from one user would be overwritten by another user when exiting Qt Assistant.

To solve this dilemma, Qt Assistant creates user specific collection files which are more or less copied from the original collection file. The user-\/specific collection file will be saved in a subdirectory of the path returned by Q\-Desktop\-Services\-::\-Data\-Location. The subdirectory, or cache directory within this user-\/specific location, can be defined in the help collection project file. For example\-:

$<$?xml version=\char`\"{}1.\-0\char`\"{} encoding=\char`\"{}utf-\/8\char`\"{} ?$>$ $<$\-Q\-Help\-Collection\-Project version=\char`\"{}1.\-0\char`\"{}$>$ $<$assistant$>$ $<$title$>$My Application Help$<$/title$>$ $<$cache\-Directory$>$mycompany/myapplication$<$/cache\-Directory$>$ ... $<$/assistant$>$ $<$/\-Q\-Help\-Collection\-Project$>$

So, when calling

assistant -\/collection\-File mycollection.\-qhc

Qt Assistant actually uses the collection file\-:

Q\-Desktop\-Services\-::\-Data\-Location\%/mycompany/myapplication/mycollection.qhc

There is no need ever to start Qt Assistant with the user specific collection file. Instead, the collection file shipped with the application should always be used. Also, when adding or removing documentation from the collection file (see next section) always use the normal collection file. Qt Assistant will take care of synchronizing the user collection files when the list of installed documentation has changed.\hypertarget{assistant_assisant_custom}{}\subsection{Displaying Custom Documentation}\label{assistant_assisant_custom}
Before Qt Assistant is able to show documentation, it has to know where it can find the actual documentation files, meaning that it has to know the location of the Qt compressed help file ($\ast$.qch). As already mentioned, Qt Assistant stores references to the compressed help files in the currently used collection file. So, when creating a new collection file you can list all compressed help files Qt Assistant should display.

$<$?xml version=\char`\"{}1.\-0\char`\"{} encoding=\char`\"{}utf-\/8\char`\"{} ?$>$ $<$\-Q\-Help\-Collection\-Project version=\char`\"{}1.\-0\char`\"{}$>$ ... $<$doc\-Files$>$ $<$register$>$ $<$file$>$myapplication-\/manual.\-qch$<$/file$>$ $<$file$>$another-\/manual.\-qch$<$/file$>$ $<$/register$>$ $<$/doc\-Files$>$ $<$/\-Q\-Help\-Collection\-Project$>$

Sometimes, depending on the application for which Qt Assistant acts as a help viewer, more documentation needs to be added over time; for example, when installing more application components or plugins. This can be done manually by starting Qt Assistant, opening the Edit$|$\-Preferences dialog and navigating to the Documentation tab page. Then click the Add... button, select a Qt compressed help file ($\ast$.qch) and press Open. However, this approach has the disadvantage that every user has to do it manually to get access to the new documentation.

The prefered way of adding documentation to an already existing collection file is to use the -\/register command line flag of Qt Assistant. When starting Qt Assistant with this flag, the documentation will be added and Qt Assistant will exit right away displaying a message if the registration was successful or not.

The search indexing will only index your custom $\ast$.html, $\ast$.htm, and $\ast$.txt files. \begin{DoxyVerb}assistant -collectionFile mycollection.qhc -register myapplication-manual.qch
\end{DoxyVerb}


The -\/quiet flag can be passed on to Qt Assistant to prevent it from writing out the status message.

Note\-: Qt Assistant will show the documentation in the contents view in the same order as it was registered. Changing the Appearance of Qt Assistant

The appearance of Qt Assistant can be changed by passing different command line options on startup. However, these command line options only allow to show or hide specific widgets, like the contents or index view. Other customizations, such as changing the application title or icon, or disabling the filter functionality, can be done by creating a custom help collection file. Creating a Custom Help Collection File

The help collection file ($\ast$.qhc) used by Qt Assistant is created when running the qcollectiongenerator tool on a help collection project file ($\ast$.qhcp). The project file format is X\-M\-L and supports the following tags\-:

\begin{TabularC}{2}
\hline
\rowcolor{lightgray}{\bf Tag }&{\bf Brief Description }\\\cline{1-2}
$<$title$>$ &This property is used to specify a window title for Qt Assistant. \\\cline{1-2}
$<$home\-Page$>$ &This tag specifies which page should be display when pressing the home button in Qt Assistant's main user interface. \\\cline{1-2}
$<$start\-Page$>$ &This tag specifies which page Qt Assistant should initially display when the help collection is used. \\\cline{1-2}
$<$current\-Filter$>$ &This tag specifies the filter that is initially used. If this filter is not specified, the documentation will not be filtered. This has no impact if only one documentation set is installed. \\\cline{1-2}
$<$application\-Icon$>$ &This tag describes an icon that will be used instead of the normal Qt Assistant application icon. This is specified as a relative path from the directory containing the collection file. \\\cline{1-2}
$<$enable\-Filter\-Functionality$>$ &This tag is used to enable or disable user accessible filter functionality, making it possible to prevent the user from changing any filter when running Qt Assistant. It does not mean that the internal filter functionality is completely disabled. Set the value to false if you want to disable the filtering. If the filter toolbar should be shown by default, set the attribute visible to true. \\\cline{1-2}
$<$enable\-Documentation\-Manager$>$ &This tag is used to specify whether the documentation manager should be shown in the preferences dialog. Disabling the Documentation Manager allows you to limit Qt Assistant to display a specific documentation set or make it impossible for the end user to accidentally remove or install documentation. To hide the documentation manager, set the tag value to false. \\\cline{1-2}
$<$enable\-Address\-Bar$>$ &This tag describes if the address bar can be shown. By default it is enabled; if you want to disable it set the tag value to false. If the address bar functionality is enabled, the address bar can be shown by setting the tag attribute visible to true. \\\cline{1-2}
$<$about\-Menu\-Text$>$, $<$text$>$ &The about\-Menu\-Text tag lists texts for different languages which will later appear in the Help menu; e.\-g., \char`\"{}\-About Application\char`\"{}. A text is specified within the text tags; the language attribute takes the two letter language name. The text is used as the default text if no language attribute is specified. \\\cline{1-2}
$<$about\-Dialog$>$, $<$file$>$, $<$icon$>$ &The about\-Dialog tag can be used to specify the text for the About dialog that can be opened from the Help menu. The text is taken from the file in the file tags. It is possible to specify a different file or any language. The icon defined by the icon tags is applied to any language. \\\cline{1-2}
\end{TabularC}
$|$$<$cache\-Directory base=\char`\"{}collection$|$default\char`\"{}$>$ $|$ The cache directory is used to store index files needed for the full text search and a copy of the collection file. The copy is needed because Qt Assistant stores all its settings in the collection file; i.\-e., it must be writable for the user. The directory is specified as a relative path. If the base attribute is set to \char`\"{}collection\char`\"{}, the path is relative to the directory the collection file resides in. If the attribute is set to \char`\"{}default\char`\"{} or if it is missing, the path is relative to the directory given by Q\-Desktop\-Services\-::\-Data\-Location. The first form is useful for collections that are used in a \char`\"{}mobile\char`\"{} way, e.\-g. carried around on a U\-S\-B stick. $|$ $|$$<$enable\-Full\-Text\-Search\-Fallback$>$ $|$ This tag describes the ability to fallback and use the full text search if a keyword can't be found in the index. This functionality can be used while remote controlling Qt Assistant. To make it available for remote control set the tag value to true. $|$

In addition to those Qt Assistant specific tags, the tags for generating and registering documentation can be used. See Qt Help Collection documentation for more information.

An example of a help collection file that uses all the available tags is shown below\-: \begin{DoxyVerb}  <?xml version="1.0" encoding="utf-8" ?>
\end{DoxyVerb}
 $<$\-Q\-Help\-Collection\-Project version=\char`\"{}1.\-0\char`\"{}$>$ $<$assistant$>$ $<$title$>$My Application Help$<$/title$>$ $<$start\-Page$>$qthelp\-://com.mycompany.\-1\-\_\-0\-\_\-0/doc/index.html$<$/start\-Page$>$ $<$current\-Filter$>$myfilter$<$/current\-Filter$>$ $<$application\-Icon$>$application.\-png$<$/application\-Icon$>$ $<$enable\-Filter\-Functionality$>$false$<$/enable\-Filter\-Functionality$>$ $<$enable\-Documentation\-Manager$>$false$<$/enable\-Documentation\-Manager$>$ $<$enable\-Address\-Bar visible=\char`\"{}true\char`\"{}$>$true$<$/enable\-Address\-Bar$>$ $<$cache\-Directory$>$mycompany/myapplication$<$/cache\-Directory$>$ $<$about\-Menu\-Text$>$ $<$text$>$About My Application$<$/text$>$ $<$text language=\char`\"{}de\char`\"{}$>$ber meine Applikation...$<$/text$>$ $<$/about\-Menu\-Text$>$ $<$about\-Dialog$>$ $<$file$>$about.\-txt$<$/file$>$ $<$file language=\char`\"{}de\char`\"{}$>$ueber.\-txt$<$/file$>$ $<$icon$>$about.\-png$<$/icon$>$ $<$/about\-Dialog$>$ $<$/assistant$>$ $<$doc\-Files$>$ $<$generate$>$ $<$file$>$ $<$input$>$myapplication-\/manual.\-qhp$<$/input$>$ $<$output$>$myapplication-\/manual.\-qch$<$/output$>$ $<$/file$>$ $<$/generate$>$ $<$register$>$ $<$file$>$myapplication-\/manual.\-qch$<$/file$>$ $<$/register$>$ $<$/doc\-Files$>$ $<$/\-Q\-Help\-Collection\-Project$>$

To create the binary collection file, run the qcollectiongenerator tool\-: \begin{DoxyVerb}  qcollectiongenerator mycollection.qhcp -o mycollection.qhc
\end{DoxyVerb}


To test the generated collection file, start Qt Assistant in the following way\-: \begin{DoxyVerb}  assistant -collectionFile mycollection.qhc
\end{DoxyVerb}
\hypertarget{assistant_assistant_remote}{}\subsection{Using Qt Assistant Remotely}\label{assistant_assistant_remote}
Even though the help viewer is a standalone application, it will mostly be launched by the application it provides help for. This approach gives the application the possibility to ask for specific help contents to be displayed as soon as the help viewer is started. Another advantage with this approach is that the application can communicate with the help viewer process and can therefore request other help contents to be shown depending on the current state of the application.

So, to use Qt Assistant as the custom help viewer of your application, simply create a Q\-Process and specify the path to the Assistant executable. In order to make Assistant listen to your application, turn on its remote control functionality by passing the -\/enable\-Remote\-Control command line option.

The following example shows how this can be done\-:

Q\-Process $\ast$process = new Q\-Process; Q\-String\-List args; args $<$$<$ Q\-Latin1\-String(\char`\"{}-\/collection\-File\char`\"{}) $<$$<$ Q\-Latin1\-String(\char`\"{}mycollection.\-qhc\char`\"{}) $<$$<$ Q\-Latin1\-String(\char`\"{}-\/enable\-Remote\-Control\char`\"{}); process-\/$>$start(Q\-Latin1\-String(\char`\"{}assistant\char`\"{}), args); if (!process-\/$>$wait\-For\-Started()) return;

Once Qt Assistant is running, you can send commands by using the stdin channel of the process. The code snippet below shows how to tell Qt Assistant to show a certain page in the documentation.

Q\-Byte\-Array ba; ba.\-append(\char`\"{}set\-Source qthelp\-://com.\-mycompany.\-1\-\_\-0\-\_\-0/doc/index.\-html\textbackslash{}n\char`\"{}); process-\/$>$write(ba);

Note that the trailing newline character is required to mark the end of the input.

The following commands can be used to control Qt Assistant\-:

\begin{TabularC}{2}
\hline
\rowcolor{lightgray}{\bf Command }&{\bf Brief Description }\\\cline{1-2}
show $<$\-Widget$>$ &Shows the dock widget specified by $<$\-Widget$>$. If the widget is already shown and this command is sent again, the widget will be activated, meaning that it will be raised and given the input focus. Possible values for $<$\-Widget$>$ are \char`\"{}contents\char`\"{}, \char`\"{}index\char`\"{}, \char`\"{}bookmarks\char`\"{} or \char`\"{}search\char`\"{}. \\\cline{1-2}
hide $<$\-Widget$>$ &Hides the dock widget specified by $<$\-Widget$>$. Possible values for $<$\-Widget$>$ are \char`\"{}contents\char`\"{}, \char`\"{}index\char`\"{}, \char`\"{}bookmarks\char`\"{} and \char`\"{}search\char`\"{}. \\\cline{1-2}
set\-Source $<$\-Url$>$ &Displays the given $<$\-Url$>$. The U\-R\-L can be absolute or relative to the currently displayed page. If the U\-R\-L is absolute, it has to be a valid Qt help system U\-R\-L; i.\-e., starting with \char`\"{}qthelp\-://\char`\"{}. \\\cline{1-2}
activate\-Keyword $<$\-Keyword$>$ &Inserts the specified $<$\-Keyword$>$ into the line edit of the index dock widget and activates the corresponding item in the index list. If such an item has more than one link associated with it, a topic chooser will be shown. \\\cline{1-2}
activate\-Identifier $<$\-Id$>$ &Displays the help contents for the given $<$\-Id$>$. An I\-D is unique in each namespace and has only one link associated to it, so the topic chooser will never pop up. \\\cline{1-2}
sync\-Contents &Selects the item in the contents widget which corresponds to the currently displayed page. \\\cline{1-2}
set\-Current\-Filter $<$filter$>$ &Selects the specified filter and updates the visual representation accordingly. \\\cline{1-2}
expand\-Toc $<$\-Depth$>$ &Expands the table of contents tree to the given depth. If depth is 0, the tree will be collapsed completely. If depth is -\/1, the tree will be expanded completely. \\\cline{1-2}
register $<$help file$>$=\char`\"{}\char`\"{}$>$ &Adds the given Qt compressed help file to the collection. \\\cline{1-2}
unregister $<$help file$>$=\char`\"{}\char`\"{}$>$ &Removes the given Qt compressed help file from the collection. \\\cline{1-2}
\end{TabularC}


If you want to send several commands within a short period of time, it is recommended that you write only a single line to the stdin of the process instead of one line for every command. The commands have to be separated by a semicolon, as shown in the following example\-:

Q\-Byte\-Array ba; ba.\-append(\char`\"{}hide bookmarks;\char`\"{}); ba.\-append(\char`\"{}hide index;\char`\"{}); ba.\-append(\char`\"{}set\-Source qthelp\-://com.\-mycompany.\-1\-\_\-0\-\_\-0/doc/index.\-html\textbackslash{}n\char`\"{}); process-\/$>$write(ba);\hypertarget{assistant_assitant_compat}{}\subsection{Compatibility with Old Formats}\label{assistant_assitant_compat}
In older versions of Qt, the help system was based on Document Content File (D\-C\-F) and Qt Assistant Documentation Profile (A\-D\-P) formats. In contrast, Qt Assistant and the help system used in Qt 4.\-4 use the formats described earlier in this manual.

Unfortunately, the old file formats are not compatible with the new ones. In general, the differences are not that big  in most cases is the old format is just a subset of the new one. One example is the namespace tag in the Qt Help Project format, which was not part of the old format, but plays a vital role in the new one. To help you to move to the new file format, we have created a conversion wizard.

The wizard is started by executing qhelpconverter. It guides you through the conversion of different parts of the file and generates a new qch or qhcp file.

Once the wizard is finished and the files created, run the qhelpgenerator or the qcollectiongenerator tool to generate the binary help files used by Qt Assistant. \hypertarget{helpengine_api}{}\section{Qt Help Engine A\-P\-I}\label{helpengine_api}
\hypertarget{helpengine_api_helpengine_api}{}\subsection{Qt Help Engine A\-P\-I}\label{helpengine_api_helpengine_api}
Instead of showing the help in an external application like the Qt Assistant, it is also possible to embed the online help in the application. The contents can then be retrieved via the Q\-Help\-Engine class and can be displayed in nearly any form. Showing it in a Q\-Text\-Browser is probably the most common way, but embedding it in What's This help is also perfectly possible.

Retrieving help data from the file engine does not involve a lot of code. The first step is to create an instance of the help engine. Then we ask the engine for the links assigned to the identifier, in this case \char`\"{}\-My\-Dialog\-::\-Change\-Button\char`\"{}. If a link was found, meaning at least one help document exists to this topic, we get the actual help contents by calling file\-Data() and display the document to the user.

Q\-Help\-Engine\-Core help\-Engine(\char`\"{}mycollection.\-qhc\char`\"{}); ...

get all file references for the identifier Q\-Map$<$\-Q\-String, Q\-Url$>$ links = help\-Engine.\-links\-For\-Identifier(Q\-Latin1\-String(\char`\"{}\-My\-Dialog\-::\-Change\-Button\char`\"{}));

If help is available for this keyword, get the help data of the first file reference. if (links.\-count()) \{ Q\-Byte\-Array help\-Data = help\-Engine-\/$>$file\-Data(links.\-const\-Begin().value()); show the documentation to the user if (!help\-Data.is\-Empty()) display\-Help(help\-Data); \}

For further information on how to use the A\-P\-I, have a look at the Q\-Help\-Engine class reference. 
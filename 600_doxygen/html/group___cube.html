<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>oFreq: Cube</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenSEAImage.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">oFreq
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">Frequency Domain System Analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___cube.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cube</div>  </div>
<div class="ingroups"><a class="el" href="group__mt_sp_op.html">MtSpOp</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Cube:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___cube.png" border="0" alt="" usemap="#group______cube"/>
<!-- MAP 0 -->
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarma_1_1_cube__prealloc.html">arma::Cube_prealloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarma_1_1_cube.html">arma::Cube&lt; eT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense cube class.  <a href="classarma_1_1_cube.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarma_1_1_cube_1_1fixed.html">arma::Cube&lt; eT &gt;::fixed&lt; fixed_n_rows, fixed_n_cols, fixed_n_slices &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarma_1_1_cube__aux.html">arma::Cube_aux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8a1689ab31561d9ffcbf09f00f5e3965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga8a1689ab31561d9ffcbf09f00f5e3965">arma::Cube&lt; eT &gt;::init_warm</a> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:ga8a1689ab31561d9ffcbf09f00f5e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bac41399b3c1d815c20e540032bfe5e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0bac41399b3c1d815c20e540032bfe5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0bac41399b3c1d815c20e540032bfe5e">arma::Cube&lt; eT &gt;::init</a> (const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T1 &gt; &amp;X, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T2 &gt; &amp;Y)</td></tr>
<tr class="memdesc:ga0bac41399b3c1d815c20e540032bfe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">for constructing a complex cube out of two non-complex cubes  <a href="#ga0bac41399b3c1d815c20e540032bfe5e"></a><br/></td></tr>
<tr class="separator:ga0bac41399b3c1d815c20e540032bfe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73fd2fa4151f5bd8dab023d73c8731ba"><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga73fd2fa4151f5bd8dab023d73c8731ba">arma::Cube&lt; eT &gt;::operator=</a> (const eT val)</td></tr>
<tr class="separator:ga73fd2fa4151f5bd8dab023d73c8731ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab7e9933fa8e895918e59cdde8a5b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga7ab7e9933fa8e895918e59cdde8a5b30">arma::Cube&lt; eT &gt;::Cube</a> (eT *aux_mem, const uword aux_n_rows, const uword aux_n_cols, const uword aux_n_slices, const bool copy_aux_mem=true, const bool strict=true)</td></tr>
<tr class="separator:ga7ab7e9933fa8e895918e59cdde8a5b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a5268589f8e171a9ff405d2746e52b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gac9a5268589f8e171a9ff405d2746e52b">arma::Cube&lt; eT &gt;::Cube</a> (const eT *aux_mem, const uword aux_n_rows, const uword aux_n_cols, const uword aux_n_slices)</td></tr>
<tr class="separator:gac9a5268589f8e171a9ff405d2746e52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe36e247311a9f70ffbcbf7661cd9797"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafe36e247311a9f70ffbcbf7661cd9797"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafe36e247311a9f70ffbcbf7661cd9797"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gafe36e247311a9f70ffbcbf7661cd9797">arma::Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T1 &gt; &amp;A, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:gafe36e247311a9f70ffbcbf7661cd9797"><td class="mdescLeft">&#160;</td><td class="mdescRight">for constructing a complex cube out of two non-complex cubes <br/></td></tr>
<tr class="separator:gafe36e247311a9f70ffbcbf7661cd9797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf078433be12abde746651319f32d0549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf078433be12abde746651319f32d0549">arma::Cube&lt; eT &gt;::insert_slices</a> (const uword slice_num, const uword N, const bool set_to_zero=true)</td></tr>
<tr class="separator:gaf078433be12abde746651319f32d0549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga91d16fa2835700a338e87bc5dc9ce8fd">arma::Cube&lt; eT &gt;::insert_slices</a> (const uword row_num, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;X)</td></tr>
<tr class="separator:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b2d2e78a972c809049bc4a093298b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gac9b2d2e78a972c809049bc4a093298b7">arma::Cube&lt; eT &gt;::impl_print</a> (const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gac9b2d2e78a972c809049bc4a093298b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4412ed27ad094df35a143cd77864fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5c4412ed27ad094df35a143cd77864fe">arma::Cube&lt; eT &gt;::impl_print</a> (std::ostream &amp;user_stream, const std::string &amp;extra_text) const </td></tr>
<tr class="separator:ga5c4412ed27ad094df35a143cd77864fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdee61973e0e18bec6cb0a67f141dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gabbdee61973e0e18bec6cb0a67f141dad">arma::Cube&lt; eT &gt;::impl_raw_print</a> (const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gabbdee61973e0e18bec6cb0a67f141dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19">arma::Cube&lt; eT &gt;::impl_raw_print</a> (std::ostream &amp;user_stream, const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87057a7771d11368c688d0f86cc9660"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa87057a7771d11368c688d0f86cc9660"></a>
template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:gaa87057a7771d11368c688d0f86cc9660"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arma::Cube&lt; eT &gt;::set_real</b> (const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T1 &gt; &amp;X)</td></tr>
<tr class="separator:gaa87057a7771d11368c688d0f86cc9660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7735a855302221efcea2bcdf2f82bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="gacc7735a855302221efcea2bcdf2f82bb"></a>
template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:gacc7735a855302221efcea2bcdf2f82bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arma::Cube&lt; eT &gt;::set_imag</b> (const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::pod_type, T1 &gt; &amp;X)</td></tr>
<tr class="separator:gacc7735a855302221efcea2bcdf2f82bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga70006d5a49f67d35d4ae10cb6c5a681f">arma::Cube&lt; eT &gt;::steal_mem</a> (<a class="el" href="class_cube.html">Cube</a> &amp;X)</td></tr>
<tr class="memdesc:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't use this unless you're writing code internal to Armadillo  <a href="#ga70006d5a49f67d35d4ae10cb6c5a681f"></a><br/></td></tr>
<tr class="separator:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4fd7b21768e1061cb33207cd6b4f7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa4fd7b21768e1061cb33207cd6b4f7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaaa4fd7b21768e1061cb33207cd6b4f7a">Cube&lt; eT &gt;::Cube</a> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="memdesc:gaaa4fd7b21768e1061cb33207cd6b4f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the cube to have user specified dimensions <br/></td></tr>
<tr class="separator:gaaa4fd7b21768e1061cb33207cd6b4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada3f7ac19a66eee5fbcd4cc0201e79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaada3f7ac19a66eee5fbcd4cc0201e79b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::init_cold</b> ()</td></tr>
<tr class="separator:gaada3f7ac19a66eee5fbcd4cc0201e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a1689ab31561d9ffcbf09f00f5e3965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga8a1689ab31561d9ffcbf09f00f5e3965">Cube&lt; eT &gt;::init_warm</a> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:ga8a1689ab31561d9ffcbf09f00f5e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261fe3edd2f2706d3ad7875487cd3c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga261fe3edd2f2706d3ad7875487cd3c69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::delete_mat</b> ()</td></tr>
<tr class="separator:ga261fe3edd2f2706d3ad7875487cd3c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc39b7915eec73d01dbd1b959cb6732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1bc39b7915eec73d01dbd1b959cb6732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::create_mat</b> ()</td></tr>
<tr class="separator:ga1bc39b7915eec73d01dbd1b959cb6732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73fd2fa4151f5bd8dab023d73c8731ba"><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga73fd2fa4151f5bd8dab023d73c8731ba">Cube&lt; eT &gt;::operator=</a> (const eT val)</td></tr>
<tr class="separator:ga73fd2fa4151f5bd8dab023d73c8731ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ca23e58aac88ec2a723ebeae7a60e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6ca23e58aac88ec2a723ebeae7a60e1"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gad6ca23e58aac88ec2a723ebeae7a60e1">Cube&lt; eT &gt;::operator+=</a> (const eT val)</td></tr>
<tr class="memdesc:gad6ca23e58aac88ec2a723ebeae7a60e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition of a scalar to all elements of the cube. <br/></td></tr>
<tr class="separator:gad6ca23e58aac88ec2a723ebeae7a60e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd9657cc414a01c77ddaecf06c072ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdd9657cc414a01c77ddaecf06c072ed"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gafdd9657cc414a01c77ddaecf06c072ed">Cube&lt; eT &gt;::operator-=</a> (const eT val)</td></tr>
<tr class="memdesc:gafdd9657cc414a01c77ddaecf06c072ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtraction of a scalar from all elements of the cube. <br/></td></tr>
<tr class="separator:gafdd9657cc414a01c77ddaecf06c072ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348b03ddc6dbaebf2bcddf2625947980"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga348b03ddc6dbaebf2bcddf2625947980"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga348b03ddc6dbaebf2bcddf2625947980">Cube&lt; eT &gt;::operator*=</a> (const eT val)</td></tr>
<tr class="memdesc:ga348b03ddc6dbaebf2bcddf2625947980"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiplication of all elements of the cube with a scalar. <br/></td></tr>
<tr class="separator:ga348b03ddc6dbaebf2bcddf2625947980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d5d0e8391797cd3eac772147297b43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40d5d0e8391797cd3eac772147297b43"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga40d5d0e8391797cd3eac772147297b43">Cube&lt; eT &gt;::operator/=</a> (const eT val)</td></tr>
<tr class="memdesc:ga40d5d0e8391797cd3eac772147297b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place division of all elements of the cube with a scalar. <br/></td></tr>
<tr class="separator:ga40d5d0e8391797cd3eac772147297b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458bec1f3fc6ebb878d88eaaae747089"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga458bec1f3fc6ebb878d88eaaae747089"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga458bec1f3fc6ebb878d88eaaae747089">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:ga458bec1f3fc6ebb878d88eaaae747089"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a cube from a given cube <br/></td></tr>
<tr class="separator:ga458bec1f3fc6ebb878d88eaaae747089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga2c4c1a84d9c3e8c2c59f4759a6e3a1af">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a cube from a given cube <br/></td></tr>
<tr class="separator:ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab7e9933fa8e895918e59cdde8a5b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga7ab7e9933fa8e895918e59cdde8a5b30">Cube&lt; eT &gt;::Cube</a> (eT *aux_mem, const uword aux_n_rows, const uword aux_n_cols, const uword aux_n_slices, const bool copy_aux_mem=true, const bool strict=true)</td></tr>
<tr class="separator:ga7ab7e9933fa8e895918e59cdde8a5b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a5268589f8e171a9ff405d2746e52b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gac9a5268589f8e171a9ff405d2746e52b">Cube&lt; eT &gt;::Cube</a> (const eT *aux_mem, const uword aux_n_rows, const uword aux_n_cols, const uword aux_n_slices)</td></tr>
<tr class="separator:gac9a5268589f8e171a9ff405d2746e52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031db49c5ce03bf5fbdd6f141a784125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga031db49c5ce03bf5fbdd6f141a784125"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga031db49c5ce03bf5fbdd6f141a784125">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:ga031db49c5ce03bf5fbdd6f141a784125"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition <br/></td></tr>
<tr class="separator:ga031db49c5ce03bf5fbdd6f141a784125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc85205e8a9fd17f18566b8b3a03c70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafcc85205e8a9fd17f18566b8b3a03c70"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gafcc85205e8a9fd17f18566b8b3a03c70">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:gafcc85205e8a9fd17f18566b8b3a03c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction <br/></td></tr>
<tr class="separator:gafcc85205e8a9fd17f18566b8b3a03c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4729f1623baf2c96b9cca73e06a9a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e4729f1623baf2c96b9cca73e06a9a2"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6e4729f1623baf2c96b9cca73e06a9a2">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:ga6e4729f1623baf2c96b9cca73e06a9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place element-wise cube multiplication <br/></td></tr>
<tr class="separator:ga6e4729f1623baf2c96b9cca73e06a9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996bc9ab51f31e1a32694bb6a1b95520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga996bc9ab51f31e1a32694bb6a1b95520"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga996bc9ab51f31e1a32694bb6a1b95520">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="class_cube.html">Cube</a> &amp;m)</td></tr>
<tr class="memdesc:ga996bc9ab51f31e1a32694bb6a1b95520"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place element-wise cube division <br/></td></tr>
<tr class="separator:ga996bc9ab51f31e1a32694bb6a1b95520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edb2ac646b7408343aba2971b181104"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5edb2ac646b7408343aba2971b181104"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5edb2ac646b7408343aba2971b181104">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:ga5edb2ac646b7408343aba2971b181104"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a cube from a <a class="el" href="classsubview__cube.html">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation) <br/></td></tr>
<tr class="separator:ga5edb2ac646b7408343aba2971b181104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6fc51265fb78aa3b5e69e7ce51bff6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6fc51265fb78aa3b5e69e7ce51bff6f"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab6fc51265fb78aa3b5e69e7ce51bff6f">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:gab6fc51265fb78aa3b5e69e7ce51bff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a cube from a <a class="el" href="classsubview__cube.html">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation) <br/></td></tr>
<tr class="separator:gab6fc51265fb78aa3b5e69e7ce51bff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ff823e63a04d322137bab296fd40c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7ff823e63a04d322137bab296fd40c0"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab7ff823e63a04d322137bab296fd40c0">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:gab7ff823e63a04d322137bab296fd40c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition (using a subcube on the right-hand-side) <br/></td></tr>
<tr class="separator:gab7ff823e63a04d322137bab296fd40c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab188ca927465a03ded825df6cb8c8d5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab188ca927465a03ded825df6cb8c8d5e"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab188ca927465a03ded825df6cb8c8d5e">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:gab188ca927465a03ded825df6cb8c8d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction (using a subcube on the right-hand-side) <br/></td></tr>
<tr class="separator:gab188ca927465a03ded825df6cb8c8d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32382263d12d93c74b5593145a7250c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae32382263d12d93c74b5593145a7250c"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gae32382263d12d93c74b5593145a7250c">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:gae32382263d12d93c74b5593145a7250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place element-wise cube mutiplication (using a subcube on the right-hand-side) <br/></td></tr>
<tr class="separator:gae32382263d12d93c74b5593145a7250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4769b282b8a4a39a15b52a6131c1acc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4769b282b8a4a39a15b52a6131c1acc6"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga4769b282b8a4a39a15b52a6131c1acc6">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr class="memdesc:ga4769b282b8a4a39a15b52a6131c1acc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place element-wise cube division (using a subcube on the right-hand-side) <br/></td></tr>
<tr class="separator:ga4769b282b8a4a39a15b52a6131c1acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4599ae61da89772bdc085491c07280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b4599ae61da89772bdc085491c07280"></a>
arma_inline <a class="el" href="class_mat.html">Mat</a>&lt; eT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3b4599ae61da89772bdc085491c07280">Cube&lt; eT &gt;::slice</a> (const uword in_slice)</td></tr>
<tr class="memdesc:ga3b4599ae61da89772bdc085491c07280"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the reference to the matrix representing a single slice <br/></td></tr>
<tr class="separator:ga3b4599ae61da89772bdc085491c07280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3754918d0955861ab56ddd65ac420070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3754918d0955861ab56ddd65ac420070"></a>
arma_inline const <a class="el" href="class_mat.html">Mat</a>&lt; eT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3754918d0955861ab56ddd65ac420070">Cube&lt; eT &gt;::slice</a> (const uword in_slice) const </td></tr>
<tr class="memdesc:ga3754918d0955861ab56ddd65ac420070"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the reference to the matrix representing a single slice <br/></td></tr>
<tr class="separator:ga3754918d0955861ab56ddd65ac420070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b0a6a1df400f361d4b7877b23f08cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8b0a6a1df400f361d4b7877b23f08cb"></a>
arma_inline <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab8b0a6a1df400f361d4b7877b23f08cb">Cube&lt; eT &gt;::slices</a> (const uword in_slice1, const uword in_slice2)</td></tr>
<tr class="memdesc:gab8b0a6a1df400f361d4b7877b23f08cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (subcube comprised of specified slices) <br/></td></tr>
<tr class="separator:gab8b0a6a1df400f361d4b7877b23f08cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93482f656697c945cd0430f0bd4c017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa93482f656697c945cd0430f0bd4c017"></a>
arma_inline const <a class="el" href="classsubview__cube.html">subview_cube</a><br class="typebreak"/>
&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaa93482f656697c945cd0430f0bd4c017">Cube&lt; eT &gt;::slices</a> (const uword in_slice1, const uword in_slice2) const </td></tr>
<tr class="memdesc:gaa93482f656697c945cd0430f0bd4c017"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (subcube comprised of specified slices) <br/></td></tr>
<tr class="separator:gaa93482f656697c945cd0430f0bd4c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaee971a4703218c607d46a5189c269c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeaee971a4703218c607d46a5189c269c"></a>
arma_inline <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaeaee971a4703218c607d46a5189c269c">Cube&lt; eT &gt;::subcube</a> (const uword in_row1, const uword in_col1, const uword in_slice1, const uword in_row2, const uword in_col2, const uword in_slice2)</td></tr>
<tr class="memdesc:gaeaee971a4703218c607d46a5189c269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (generic subcube) <br/></td></tr>
<tr class="separator:gaeaee971a4703218c607d46a5189c269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d083cc54fbf5247814e55aec5a3f7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d083cc54fbf5247814e55aec5a3f7d6"></a>
arma_inline const <a class="el" href="classsubview__cube.html">subview_cube</a><br class="typebreak"/>
&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga4d083cc54fbf5247814e55aec5a3f7d6">Cube&lt; eT &gt;::subcube</a> (const uword in_row1, const uword in_col1, const uword in_slice1, const uword in_row2, const uword in_col2, const uword in_slice2) const </td></tr>
<tr class="memdesc:ga4d083cc54fbf5247814e55aec5a3f7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (generic subcube) <br/></td></tr>
<tr class="separator:ga4d083cc54fbf5247814e55aec5a3f7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd724cbbf9a49abc311be9dd938d6e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacbd724cbbf9a49abc311be9dd938d6e0"></a>
<a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gacbd724cbbf9a49abc311be9dd938d6e0">Cube&lt; eT &gt;::subcube</a> (const <a class="el" href="classspan.html">span</a> &amp;row_span, const <a class="el" href="classspan.html">span</a> &amp;col_span, const <a class="el" href="classspan.html">span</a> &amp;slice_span)</td></tr>
<tr class="memdesc:gacbd724cbbf9a49abc311be9dd938d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (generic subcube) <br/></td></tr>
<tr class="separator:gacbd724cbbf9a49abc311be9dd938d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7a1d8eb682ddf27eab9694fc193499"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba7a1d8eb682ddf27eab9694fc193499"></a>
const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaba7a1d8eb682ddf27eab9694fc193499">Cube&lt; eT &gt;::subcube</a> (const <a class="el" href="classspan.html">span</a> &amp;row_span, const <a class="el" href="classspan.html">span</a> &amp;col_span, const <a class="el" href="classspan.html">span</a> &amp;slice_span) const </td></tr>
<tr class="memdesc:gaba7a1d8eb682ddf27eab9694fc193499"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of <a class="el" href="classsubview__cube.html">subview_cube</a> (generic subcube) <br/></td></tr>
<tr class="separator:gaba7a1d8eb682ddf27eab9694fc193499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6af9768762da86e088845c1f0c11eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc6af9768762da86e088845c1f0c11eb"></a>
<a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator()</b> (const <a class="el" href="classspan.html">span</a> &amp;row_span, const <a class="el" href="classspan.html">span</a> &amp;col_span, const <a class="el" href="classspan.html">span</a> &amp;slice_span)</td></tr>
<tr class="separator:gafc6af9768762da86e088845c1f0c11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62f8c962a512d04126104f615d896e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab62f8c962a512d04126104f615d896e3"></a>
const <a class="el" href="classsubview__cube.html">subview_cube</a>&lt; eT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator()</b> (const <a class="el" href="classspan.html">span</a> &amp;row_span, const <a class="el" href="classspan.html">span</a> &amp;col_span, const <a class="el" href="classspan.html">span</a> &amp;slice_span) const </td></tr>
<tr class="separator:gab62f8c962a512d04126104f615d896e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6a612fc14b303ada4a471dd535ccc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b6a612fc14b303ada4a471dd535ccc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5b6a612fc14b303ada4a471dd535ccc8">Cube&lt; eT &gt;::shed_slice</a> (const uword slice_num)</td></tr>
<tr class="memdesc:ga5b6a612fc14b303ada4a471dd535ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove specified slice <br/></td></tr>
<tr class="separator:ga5b6a612fc14b303ada4a471dd535ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa0b0a8dde177365a95264389920315"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0aa0b0a8dde177365a95264389920315"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0aa0b0a8dde177365a95264389920315">Cube&lt; eT &gt;::shed_slices</a> (const uword in_slice1, const uword in_slice2)</td></tr>
<tr class="memdesc:ga0aa0b0a8dde177365a95264389920315"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove specified slices <br/></td></tr>
<tr class="separator:ga0aa0b0a8dde177365a95264389920315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf078433be12abde746651319f32d0549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf078433be12abde746651319f32d0549">Cube&lt; eT &gt;::insert_slices</a> (const uword slice_num, const uword N, const bool set_to_zero=true)</td></tr>
<tr class="separator:gaf078433be12abde746651319f32d0549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga91d16fa2835700a338e87bc5dc9ce8fd">Cube&lt; eT &gt;::insert_slices</a> (const uword row_num, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;X)</td></tr>
<tr class="separator:ga91d16fa2835700a338e87bc5dc9ce8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4374b5d2d89f8a368f4fc7b673bf85c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf4374b5d2d89f8a368f4fc7b673bf85c"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:gaf4374b5d2d89f8a368f4fc7b673bf85c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf4374b5d2d89f8a368f4fc7b673bf85c">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gaf4374b5d2d89f8a368f4fc7b673bf85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_op_cube.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations <br/></td></tr>
<tr class="separator:gaf4374b5d2d89f8a368f4fc7b673bf85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757e992e05629e9d146e0a9f25d10a3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga757e992e05629e9d146e0a9f25d10a3a"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:ga757e992e05629e9d146e0a9f25d10a3a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator=</b> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="separator:ga757e992e05629e9d146e0a9f25d10a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e1da07efcebb0969b0715a4e59b0ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga38e1da07efcebb0969b0715a4e59b0ca"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:ga38e1da07efcebb0969b0715a4e59b0ca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator+=</b> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="separator:ga38e1da07efcebb0969b0715a4e59b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1f8303b2ac4294993524d3462e1e3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9e1f8303b2ac4294993524d3462e1e3a"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:ga9e1f8303b2ac4294993524d3462e1e3a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator-=</b> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="separator:ga9e1f8303b2ac4294993524d3462e1e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08fedfbaa77e0996bf882780b3a407f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad08fedfbaa77e0996bf882780b3a407f"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:gad08fedfbaa77e0996bf882780b3a407f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator%=</b> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="separator:gad08fedfbaa77e0996bf882780b3a407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912669eb01833cd2bc6499110327839e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga912669eb01833cd2bc6499110327839e"></a>
template&lt;typename gen_type &gt; </td></tr>
<tr class="memitem:ga912669eb01833cd2bc6499110327839e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube&lt; eT &gt;::operator/=</b> (const <a class="el" href="class_gen_cube.html">GenCube</a>&lt; eT, gen_type &gt; &amp;X)</td></tr>
<tr class="separator:ga912669eb01833cd2bc6499110327839e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db595f899002f017191c2bb9ab4365f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3db595f899002f017191c2bb9ab4365f"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga3db595f899002f017191c2bb9ab4365f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3db595f899002f017191c2bb9ab4365f">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga3db595f899002f017191c2bb9ab4365f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_op_cube.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations <br/></td></tr>
<tr class="separator:ga3db595f899002f017191c2bb9ab4365f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83f2cae813e5109bf6257fb5449a50a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab83f2cae813e5109bf6257fb5449a50a"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:gab83f2cae813e5109bf6257fb5449a50a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gab83f2cae813e5109bf6257fb5449a50a">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gab83f2cae813e5109bf6257fb5449a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_op_cube.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations <br/></td></tr>
<tr class="separator:gab83f2cae813e5109bf6257fb5449a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad174504dea7660999c31110a16d3671e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad174504dea7660999c31110a16d3671e"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:gad174504dea7660999c31110a16d3671e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gad174504dea7660999c31110a16d3671e">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gad174504dea7660999c31110a16d3671e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:gad174504dea7660999c31110a16d3671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530110dfa760c13b37ef5ccaee687080"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga530110dfa760c13b37ef5ccaee687080"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga530110dfa760c13b37ef5ccaee687080"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga530110dfa760c13b37ef5ccaee687080">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga530110dfa760c13b37ef5ccaee687080"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga530110dfa760c13b37ef5ccaee687080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eac70859ff6628f7dcef9edafed6fd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5eac70859ff6628f7dcef9edafed6fd7"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga5eac70859ff6628f7dcef9edafed6fd7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5eac70859ff6628f7dcef9edafed6fd7">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga5eac70859ff6628f7dcef9edafed6fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga5eac70859ff6628f7dcef9edafed6fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f471e5e66eb709ee0f7a243294e193c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0f471e5e66eb709ee0f7a243294e193c"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga0f471e5e66eb709ee0f7a243294e193c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0f471e5e66eb709ee0f7a243294e193c">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="class_op_cube.html">OpCube</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga0f471e5e66eb709ee0f7a243294e193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga0f471e5e66eb709ee0f7a243294e193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8bf9590e708f9918264b27af66a74d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac8bf9590e708f9918264b27af66a74d4"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:gac8bf9590e708f9918264b27af66a74d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gac8bf9590e708f9918264b27af66a74d4">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gac8bf9590e708f9918264b27af66a74d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="classe_op_cube.html">eOpCube</a>, i.e. run the previously delayed unary operations <br/></td></tr>
<tr class="separator:gac8bf9590e708f9918264b27af66a74d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49019d6d67ef03eaff9fc179eeee709"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa49019d6d67ef03eaff9fc179eeee709"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:gaa49019d6d67ef03eaff9fc179eeee709"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gaa49019d6d67ef03eaff9fc179eeee709">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gaa49019d6d67ef03eaff9fc179eeee709"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="classe_op_cube.html">eOpCube</a>, i.e. run the previously delayed unary operations <br/></td></tr>
<tr class="separator:gaa49019d6d67ef03eaff9fc179eeee709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75decfd6e54b24ac77474f9e34c341a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf75decfd6e54b24ac77474f9e34c341a"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:gaf75decfd6e54b24ac77474f9e34c341a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf75decfd6e54b24ac77474f9e34c341a">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gaf75decfd6e54b24ac77474f9e34c341a"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:gaf75decfd6e54b24ac77474f9e34c341a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdac75d815020e8f1928cd2fc963d8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0bdac75d815020e8f1928cd2fc963d8e"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:ga0bdac75d815020e8f1928cd2fc963d8e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0bdac75d815020e8f1928cd2fc963d8e">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga0bdac75d815020e8f1928cd2fc963d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga0bdac75d815020e8f1928cd2fc963d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794fe2b7beb612bc62be73d49086e891"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga794fe2b7beb612bc62be73d49086e891"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:ga794fe2b7beb612bc62be73d49086e891"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga794fe2b7beb612bc62be73d49086e891">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga794fe2b7beb612bc62be73d49086e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga794fe2b7beb612bc62be73d49086e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f517610f54d626d14243f7dff66a6ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9f517610f54d626d14243f7dff66a6ce"></a>
template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr class="memitem:ga9f517610f54d626d14243f7dff66a6ce"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga9f517610f54d626d14243f7dff66a6ce">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="classe_op_cube.html">eOpCube</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga9f517610f54d626d14243f7dff66a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operand having delayed operations <br/></td></tr>
<tr class="separator:ga9f517610f54d626d14243f7dff66a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ac5b17264f920313d1830232229146"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga27ac5b17264f920313d1830232229146"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga27ac5b17264f920313d1830232229146"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga27ac5b17264f920313d1830232229146">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga27ac5b17264f920313d1830232229146"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga27ac5b17264f920313d1830232229146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3009ff5b96e636b6c89e830e04156911"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3009ff5b96e636b6c89e830e04156911"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga3009ff5b96e636b6c89e830e04156911"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3009ff5b96e636b6c89e830e04156911">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga3009ff5b96e636b6c89e830e04156911"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga3009ff5b96e636b6c89e830e04156911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade064487f2df7a321e2065c44d4c4e76"><td class="memTemplParams" colspan="2"><a class="anchor" id="gade064487f2df7a321e2065c44d4c4e76"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:gade064487f2df7a321e2065c44d4c4e76"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gade064487f2df7a321e2065c44d4c4e76">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gade064487f2df7a321e2065c44d4c4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:gade064487f2df7a321e2065c44d4c4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c11384efc95182586256502d488757"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga59c11384efc95182586256502d488757"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga59c11384efc95182586256502d488757"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga59c11384efc95182586256502d488757">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga59c11384efc95182586256502d488757"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga59c11384efc95182586256502d488757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11724a754b6f20e2781e33fef6cc2e7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga11724a754b6f20e2781e33fef6cc2e7a"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:ga11724a754b6f20e2781e33fef6cc2e7a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga11724a754b6f20e2781e33fef6cc2e7a">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga11724a754b6f20e2781e33fef6cc2e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga11724a754b6f20e2781e33fef6cc2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8c85d00212f31cb0f77c73eb20fa89"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadc8c85d00212f31cb0f77c73eb20fa89"></a>
template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr class="memitem:gadc8c85d00212f31cb0f77c73eb20fa89"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gadc8c85d00212f31cb0f77c73eb20fa89">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="classmt_op_cube.html">mtOpCube</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gadc8c85d00212f31cb0f77c73eb20fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:gadc8c85d00212f31cb0f77c73eb20fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4278f25c80e0e5c32117a164485d60ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4278f25c80e0e5c32117a164485d60ce"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga4278f25c80e0e5c32117a164485d60ce"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga4278f25c80e0e5c32117a164485d60ce">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga4278f25c80e0e5c32117a164485d60ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_glue.html">Glue</a>, i.e. run the previously delayed binary operations <br/></td></tr>
<tr class="separator:ga4278f25c80e0e5c32117a164485d60ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd71396710d78fbf5c3717ae1511e03"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadbd71396710d78fbf5c3717ae1511e03"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:gadbd71396710d78fbf5c3717ae1511e03"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gadbd71396710d78fbf5c3717ae1511e03">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gadbd71396710d78fbf5c3717ae1511e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_glue.html">Glue</a>, i.e. run the previously delayed binary operations <br/></td></tr>
<tr class="separator:gadbd71396710d78fbf5c3717ae1511e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11429b7e0a1e8924a69e18dc14cd09c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga11429b7e0a1e8924a69e18dc14cd09c9"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga11429b7e0a1e8924a69e18dc14cd09c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga11429b7e0a1e8924a69e18dc14cd09c9">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga11429b7e0a1e8924a69e18dc14cd09c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga11429b7e0a1e8924a69e18dc14cd09c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378f3835a7af4c8e1063e9b9c22f452e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga378f3835a7af4c8e1063e9b9c22f452e"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga378f3835a7af4c8e1063e9b9c22f452e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga378f3835a7af4c8e1063e9b9c22f452e">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga378f3835a7af4c8e1063e9b9c22f452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga378f3835a7af4c8e1063e9b9c22f452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b43e3040fdc021faec8404fb306d54b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b43e3040fdc021faec8404fb306d54b"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga1b43e3040fdc021faec8404fb306d54b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1b43e3040fdc021faec8404fb306d54b">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga1b43e3040fdc021faec8404fb306d54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga1b43e3040fdc021faec8404fb306d54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51994b079a5944fbba088a04cbf982d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga51994b079a5944fbba088a04cbf982d5"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga51994b079a5944fbba088a04cbf982d5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga51994b079a5944fbba088a04cbf982d5">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="class_glue_cube.html">GlueCube</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga51994b079a5944fbba088a04cbf982d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga51994b079a5944fbba088a04cbf982d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1313643cce6b59bc92ff2b1180c48bca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1313643cce6b59bc92ff2b1180c48bca"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:ga1313643cce6b59bc92ff2b1180c48bca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1313643cce6b59bc92ff2b1180c48bca">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga1313643cce6b59bc92ff2b1180c48bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="classe_glue.html">eGlue</a>, i.e. run the previously delayed binary operations <br/></td></tr>
<tr class="separator:ga1313643cce6b59bc92ff2b1180c48bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18bcd72f862ebdbe23d9a59227b962a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab18bcd72f862ebdbe23d9a59227b962a"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:gab18bcd72f862ebdbe23d9a59227b962a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gab18bcd72f862ebdbe23d9a59227b962a">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gab18bcd72f862ebdbe23d9a59227b962a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cube from <a class="el" href="class_glue.html">Glue</a>, i.e. run the previously delayed binary operations <br/></td></tr>
<tr class="separator:gab18bcd72f862ebdbe23d9a59227b962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59e4b12aa7e5aad26858b29569d36a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa59e4b12aa7e5aad26858b29569d36a6"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:gaa59e4b12aa7e5aad26858b29569d36a6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gaa59e4b12aa7e5aad26858b29569d36a6">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gaa59e4b12aa7e5aad26858b29569d36a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:gaa59e4b12aa7e5aad26858b29569d36a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab967842c2941a0a3addfaf163cc87fc4"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab967842c2941a0a3addfaf163cc87fc4"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:gab967842c2941a0a3addfaf163cc87fc4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gab967842c2941a0a3addfaf163cc87fc4">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gab967842c2941a0a3addfaf163cc87fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:gab967842c2941a0a3addfaf163cc87fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d80136183da54a62946654c2109355"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga25d80136183da54a62946654c2109355"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:ga25d80136183da54a62946654c2109355"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga25d80136183da54a62946654c2109355">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga25d80136183da54a62946654c2109355"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga25d80136183da54a62946654c2109355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf9f7fa68de71f982665169da9b0d56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6bf9f7fa68de71f982665169da9b0d56"></a>
template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr class="memitem:ga6bf9f7fa68de71f982665169da9b0d56"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6bf9f7fa68de71f982665169da9b0d56">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="classe_glue_cube.html">eGlueCube</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga6bf9f7fa68de71f982665169da9b0d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operands having delayed operations <br/></td></tr>
<tr class="separator:ga6bf9f7fa68de71f982665169da9b0d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebd1ad669ef16656f3ebac720ca41df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9ebd1ad669ef16656f3ebac720ca41df"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga9ebd1ad669ef16656f3ebac720ca41df"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga9ebd1ad669ef16656f3ebac720ca41df">Cube&lt; eT &gt;::Cube</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga9ebd1ad669ef16656f3ebac720ca41df"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga9ebd1ad669ef16656f3ebac720ca41df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7db720b93f8f7604ca89d0fa75d7602"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf7db720b93f8f7604ca89d0fa75d7602"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:gaf7db720b93f8f7604ca89d0fa75d7602"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf7db720b93f8f7604ca89d0fa75d7602">Cube&lt; eT &gt;::operator=</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:gaf7db720b93f8f7604ca89d0fa75d7602"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:gaf7db720b93f8f7604ca89d0fa75d7602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98417344d8431d6cee5d428cd0a7bd28"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga98417344d8431d6cee5d428cd0a7bd28"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga98417344d8431d6cee5d428cd0a7bd28"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga98417344d8431d6cee5d428cd0a7bd28">Cube&lt; eT &gt;::operator+=</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga98417344d8431d6cee5d428cd0a7bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga98417344d8431d6cee5d428cd0a7bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1020ab91bcf51738c82c071fd4cca753"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1020ab91bcf51738c82c071fd4cca753"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga1020ab91bcf51738c82c071fd4cca753"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1020ab91bcf51738c82c071fd4cca753">Cube&lt; eT &gt;::operator-=</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga1020ab91bcf51738c82c071fd4cca753"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga1020ab91bcf51738c82c071fd4cca753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4656943ea099abc545a7912c3d0abd0b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4656943ea099abc545a7912c3d0abd0b"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga4656943ea099abc545a7912c3d0abd0b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga4656943ea099abc545a7912c3d0abd0b">Cube&lt; eT &gt;::operator%=</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga4656943ea099abc545a7912c3d0abd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga4656943ea099abc545a7912c3d0abd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90bbb5de0b605296223c6e0db8de4f4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga90bbb5de0b605296223c6e0db8de4f4e"></a>
template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr class="memitem:ga90bbb5de0b605296223c6e0db8de4f4e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga90bbb5de0b605296223c6e0db8de4f4e">Cube&lt; eT &gt;::operator/=</a> (const <a class="el" href="classmt_glue_cube.html">mtGlueCube</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr class="memdesc:ga90bbb5de0b605296223c6e0db8de4f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL. <br/></td></tr>
<tr class="separator:ga90bbb5de0b605296223c6e0db8de4f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1898bbebfe5bfea8c9032c9eb6e5a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace1898bbebfe5bfea8c9032c9eb6e5a9"></a>
arma_inline arma_warn_unused eT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gace1898bbebfe5bfea8c9032c9eb6e5a9">Cube&lt; eT &gt;::operator()</a> (const uword i)</td></tr>
<tr class="memdesc:gace1898bbebfe5bfea8c9032c9eb6e5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined <br/></td></tr>
<tr class="separator:gace1898bbebfe5bfea8c9032c9eb6e5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5758e9320d64c1eb46b6bdd0c6fbacfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5758e9320d64c1eb46b6bdd0c6fbacfd"></a>
arma_inline arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5758e9320d64c1eb46b6bdd0c6fbacfd">Cube&lt; eT &gt;::operator()</a> (const uword i) const </td></tr>
<tr class="memdesc:ga5758e9320d64c1eb46b6bdd0c6fbacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined <br/></td></tr>
<tr class="separator:ga5758e9320d64c1eb46b6bdd0c6fbacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b20c4387eb1b011cf7ab1335b837694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b20c4387eb1b011cf7ab1335b837694"></a>
arma_inline arma_warn_unused eT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6b20c4387eb1b011cf7ab1335b837694">Cube&lt; eT &gt;::operator[]</a> (const uword i)</td></tr>
<tr class="memdesc:ga6b20c4387eb1b011cf7ab1335b837694"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check. <br/></td></tr>
<tr class="separator:ga6b20c4387eb1b011cf7ab1335b837694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c42c0743e407cb143b10f6e9699b60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8c42c0743e407cb143b10f6e9699b60"></a>
arma_inline arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gae8c42c0743e407cb143b10f6e9699b60">Cube&lt; eT &gt;::operator[]</a> (const uword i) const </td></tr>
<tr class="memdesc:gae8c42c0743e407cb143b10f6e9699b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check <br/></td></tr>
<tr class="separator:gae8c42c0743e407cb143b10f6e9699b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cac3c7cf293f31f8e4cefa15fabb54b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cac3c7cf293f31f8e4cefa15fabb54b"></a>
arma_inline arma_warn_unused eT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5cac3c7cf293f31f8e4cefa15fabb54b">Cube&lt; eT &gt;::at</a> (const uword i)</td></tr>
<tr class="memdesc:ga5cac3c7cf293f31f8e4cefa15fabb54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check. <br/></td></tr>
<tr class="separator:ga5cac3c7cf293f31f8e4cefa15fabb54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15db5e9adc152838fc796791c61add4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab15db5e9adc152838fc796791c61add4"></a>
arma_inline arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab15db5e9adc152838fc796791c61add4">Cube&lt; eT &gt;::at</a> (const uword i) const </td></tr>
<tr class="memdesc:gab15db5e9adc152838fc796791c61add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check <br/></td></tr>
<tr class="separator:gab15db5e9adc152838fc796791c61add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65b7c122cfbdc3a814857621dc63540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae65b7c122cfbdc3a814857621dc63540"></a>
arma_inline arma_warn_unused eT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gae65b7c122cfbdc3a814857621dc63540">Cube&lt; eT &gt;::operator()</a> (const uword in_row, const uword in_col, const uword in_slice)</td></tr>
<tr class="memdesc:gae65b7c122cfbdc3a814857621dc63540"><td class="mdescLeft">&#160;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined <br/></td></tr>
<tr class="separator:gae65b7c122cfbdc3a814857621dc63540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d4b48e11908957dcffac757d1fb1cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5d4b48e11908957dcffac757d1fb1cd"></a>
arma_inline arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gad5d4b48e11908957dcffac757d1fb1cd">Cube&lt; eT &gt;::operator()</a> (const uword in_row, const uword in_col, const uword in_slice) const </td></tr>
<tr class="memdesc:gad5d4b48e11908957dcffac757d1fb1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined <br/></td></tr>
<tr class="separator:gad5d4b48e11908957dcffac757d1fb1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54dd3c89612beb059991f087d24afe38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54dd3c89612beb059991f087d24afe38"></a>
arma_inline arma_warn_unused eT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga54dd3c89612beb059991f087d24afe38">Cube&lt; eT &gt;::at</a> (const uword in_row, const uword in_col, const uword in_slice)</td></tr>
<tr class="memdesc:ga54dd3c89612beb059991f087d24afe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">element accessor; no bounds check <br/></td></tr>
<tr class="separator:ga54dd3c89612beb059991f087d24afe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f7ccd332ed6b87058b3fa13130992f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1f7ccd332ed6b87058b3fa13130992f"></a>
arma_inline arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gac1f7ccd332ed6b87058b3fa13130992f">Cube&lt; eT &gt;::at</a> (const uword in_row, const uword in_col, const uword in_slice) const </td></tr>
<tr class="memdesc:gac1f7ccd332ed6b87058b3fa13130992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">element accessor; no bounds check <br/></td></tr>
<tr class="separator:gac1f7ccd332ed6b87058b3fa13130992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f49cd73b0a28cd718820aabcbfc55b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63f49cd73b0a28cd718820aabcbfc55b"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga63f49cd73b0a28cd718820aabcbfc55b">Cube&lt; eT &gt;::operator++</a> ()</td></tr>
<tr class="memdesc:ga63f49cd73b0a28cd718820aabcbfc55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix ++ <br/></td></tr>
<tr class="separator:ga63f49cd73b0a28cd718820aabcbfc55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e53f4d13c896de95e1d6d5c187ae55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08e53f4d13c896de95e1d6d5c187ae55"></a>
arma_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga08e53f4d13c896de95e1d6d5c187ae55">Cube&lt; eT &gt;::operator++</a> (int)</td></tr>
<tr class="memdesc:ga08e53f4d13c896de95e1d6d5c187ae55"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix ++ (must not return the object by reference) <br/></td></tr>
<tr class="separator:ga08e53f4d13c896de95e1d6d5c187ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8adaf465f35b98b70c02fc3c6407ed28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8adaf465f35b98b70c02fc3c6407ed28"></a>
arma_inline const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga8adaf465f35b98b70c02fc3c6407ed28">Cube&lt; eT &gt;::operator--</a> ()</td></tr>
<tr class="memdesc:ga8adaf465f35b98b70c02fc3c6407ed28"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix &ndash; <br/></td></tr>
<tr class="separator:ga8adaf465f35b98b70c02fc3c6407ed28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f7e423acb147da1ff5eed3c24eef84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85f7e423acb147da1ff5eed3c24eef84"></a>
arma_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga85f7e423acb147da1ff5eed3c24eef84">Cube&lt; eT &gt;::operator--</a> (int)</td></tr>
<tr class="memdesc:ga85f7e423acb147da1ff5eed3c24eef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix &ndash; (must not return the object by reference) <br/></td></tr>
<tr class="separator:ga85f7e423acb147da1ff5eed3c24eef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4832eba2b46a23bd678d6f8400f3b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d4832eba2b46a23bd678d6f8400f3b6"></a>
arma_inline arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0d4832eba2b46a23bd678d6f8400f3b6">Cube&lt; eT &gt;::is_finite</a> () const </td></tr>
<tr class="memdesc:ga0d4832eba2b46a23bd678d6f8400f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if all of the elements are finite <br/></td></tr>
<tr class="separator:ga0d4832eba2b46a23bd678d6f8400f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41d9157a806d723ee13378a48ea57cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf41d9157a806d723ee13378a48ea57cd"></a>
arma_inline arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaf41d9157a806d723ee13378a48ea57cd">Cube&lt; eT &gt;::is_empty</a> () const </td></tr>
<tr class="memdesc:gaf41d9157a806d723ee13378a48ea57cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the cube has no elements <br/></td></tr>
<tr class="separator:gaf41d9157a806d723ee13378a48ea57cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4055c0a5b1a1e1df56d77dd386760c22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4055c0a5b1a1e1df56d77dd386760c22"></a>
arma_inline arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga4055c0a5b1a1e1df56d77dd386760c22">Cube&lt; eT &gt;::in_range</a> (const uword i) const </td></tr>
<tr class="memdesc:ga4055c0a5b1a1e1df56d77dd386760c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given index is currently in range <br/></td></tr>
<tr class="separator:ga4055c0a5b1a1e1df56d77dd386760c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a83f548b13ab80efc3cf6281bc3a129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a83f548b13ab80efc3cf6281bc3a129"></a>
arma_inline arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1a83f548b13ab80efc3cf6281bc3a129">Cube&lt; eT &gt;::in_range</a> (const <a class="el" href="classspan.html">span</a> &amp;x) const </td></tr>
<tr class="memdesc:ga1a83f548b13ab80efc3cf6281bc3a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given start and end indices are currently in range <br/></td></tr>
<tr class="separator:ga1a83f548b13ab80efc3cf6281bc3a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2037fbf24bbb7cf4c40d71c9f6bf1f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2037fbf24bbb7cf4c40d71c9f6bf1f75"></a>
arma_inline arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga2037fbf24bbb7cf4c40d71c9f6bf1f75">Cube&lt; eT &gt;::in_range</a> (const uword in_row, const uword in_col, const uword in_slice) const </td></tr>
<tr class="memdesc:ga2037fbf24bbb7cf4c40d71c9f6bf1f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given location is currently in range <br/></td></tr>
<tr class="separator:ga2037fbf24bbb7cf4c40d71c9f6bf1f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253a83b7b8c43aca927d37ac05f57b08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga253a83b7b8c43aca927d37ac05f57b08"></a>
arma_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::in_range</b> (const <a class="el" href="classspan.html">span</a> &amp;row_span, const <a class="el" href="classspan.html">span</a> &amp;col_span, const <a class="el" href="classspan.html">span</a> &amp;slice_span) const </td></tr>
<tr class="separator:ga253a83b7b8c43aca927d37ac05f57b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b00237224a8e3bfb05728de7c962f85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b00237224a8e3bfb05728de7c962f85"></a>
arma_inline arma_warn_unused eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5b00237224a8e3bfb05728de7c962f85">Cube&lt; eT &gt;::memptr</a> ()</td></tr>
<tr class="memdesc:ga5b00237224a8e3bfb05728de7c962f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the cube <br/></td></tr>
<tr class="separator:ga5b00237224a8e3bfb05728de7c962f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1711a8b897a562beafc9e7aa01384b86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1711a8b897a562beafc9e7aa01384b86"></a>
arma_inline arma_warn_unused <br class="typebreak"/>
const eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1711a8b897a562beafc9e7aa01384b86">Cube&lt; eT &gt;::memptr</a> () const </td></tr>
<tr class="memdesc:ga1711a8b897a562beafc9e7aa01384b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the cube <br/></td></tr>
<tr class="separator:ga1711a8b897a562beafc9e7aa01384b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa880766c421f4a9f006662c7fd96850e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa880766c421f4a9f006662c7fd96850e"></a>
arma_inline arma_warn_unused eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaa880766c421f4a9f006662c7fd96850e">Cube&lt; eT &gt;::slice_memptr</a> (const uword slice)</td></tr>
<tr class="memdesc:gaa880766c421f4a9f006662c7fd96850e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube <br/></td></tr>
<tr class="separator:gaa880766c421f4a9f006662c7fd96850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6535ddb31b5fc8e4f7f37eabbf505be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6535ddb31b5fc8e4f7f37eabbf505be8"></a>
arma_inline arma_warn_unused <br class="typebreak"/>
const eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6535ddb31b5fc8e4f7f37eabbf505be8">Cube&lt; eT &gt;::slice_memptr</a> (const uword slice) const </td></tr>
<tr class="memdesc:ga6535ddb31b5fc8e4f7f37eabbf505be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube <br/></td></tr>
<tr class="separator:ga6535ddb31b5fc8e4f7f37eabbf505be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2f22b1dae85884162f6777689e4cba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb2f22b1dae85884162f6777689e4cba"></a>
arma_inline arma_warn_unused eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gafb2f22b1dae85884162f6777689e4cba">Cube&lt; eT &gt;::slice_colptr</a> (const uword in_slice, const uword in_col)</td></tr>
<tr class="memdesc:gafb2f22b1dae85884162f6777689e4cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube <br/></td></tr>
<tr class="separator:gafb2f22b1dae85884162f6777689e4cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3834157043ea6c993f7e3bb133b234b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3834157043ea6c993f7e3bb133b234b7"></a>
arma_inline arma_warn_unused <br class="typebreak"/>
const eT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3834157043ea6c993f7e3bb133b234b7">Cube&lt; eT &gt;::slice_colptr</a> (const uword in_slice, const uword in_col) const </td></tr>
<tr class="memdesc:ga3834157043ea6c993f7e3bb133b234b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube <br/></td></tr>
<tr class="separator:ga3834157043ea6c993f7e3bb133b234b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b2d2e78a972c809049bc4a093298b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gac9b2d2e78a972c809049bc4a093298b7">Cube&lt; eT &gt;::impl_print</a> (const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gac9b2d2e78a972c809049bc4a093298b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4412ed27ad094df35a143cd77864fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5c4412ed27ad094df35a143cd77864fe">Cube&lt; eT &gt;::impl_print</a> (std::ostream &amp;user_stream, const std::string &amp;extra_text) const </td></tr>
<tr class="separator:ga5c4412ed27ad094df35a143cd77864fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdee61973e0e18bec6cb0a67f141dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gabbdee61973e0e18bec6cb0a67f141dad">Cube&lt; eT &gt;::impl_raw_print</a> (const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gabbdee61973e0e18bec6cb0a67f141dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19">Cube&lt; eT &gt;::impl_raw_print</a> (std::ostream &amp;user_stream, const std::string &amp;extra_text) const </td></tr>
<tr class="separator:gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d461586030945472fe66f7364882771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d461586030945472fe66f7364882771"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0d461586030945472fe66f7364882771">Cube&lt; eT &gt;::set_size</a> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="memdesc:ga0d461586030945472fe66f7364882771"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the cube to have user specified dimensions (data is not preserved) <br/></td></tr>
<tr class="separator:ga0d461586030945472fe66f7364882771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7aa3c70ceadd436de2f2a86b1dd10d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f7aa3c70ceadd436de2f2a86b1dd10d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga7f7aa3c70ceadd436de2f2a86b1dd10d">Cube&lt; eT &gt;::reshape</a> (const uword in_rows, const uword in_cols, const uword in_slices, const uword dim=0)</td></tr>
<tr class="memdesc:ga7f7aa3c70ceadd436de2f2a86b1dd10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the cube to have user specified dimensions (data is preserved) <br/></td></tr>
<tr class="separator:ga7f7aa3c70ceadd436de2f2a86b1dd10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756b1ab4a4bc911356c934431396edad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga756b1ab4a4bc911356c934431396edad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga756b1ab4a4bc911356c934431396edad">Cube&lt; eT &gt;::resize</a> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="memdesc:ga756b1ab4a4bc911356c934431396edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the cube to have user specified dimensions (data is preserved) <br/></td></tr>
<tr class="separator:ga756b1ab4a4bc911356c934431396edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b9f8d3c2940e18c0def9bc88e5c58e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3b9f8d3c2940e18c0def9bc88e5c58e4"></a>
template&lt;typename eT2 &gt; </td></tr>
<tr class="memitem:ga3b9f8d3c2940e18c0def9bc88e5c58e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3b9f8d3c2940e18c0def9bc88e5c58e4">Cube&lt; eT &gt;::copy_size</a> (const <a class="el" href="class_cube.html">Cube</a>&lt; eT2 &gt; &amp;m)</td></tr>
<tr class="memdesc:ga3b9f8d3c2940e18c0def9bc88e5c58e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the cube (without preserving data) to have the same dimensions as the given cube <br/></td></tr>
<tr class="separator:ga3b9f8d3c2940e18c0def9bc88e5c58e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8208e83e1cb49d6b7ca62d94e7a62ad0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8208e83e1cb49d6b7ca62d94e7a62ad0"></a>
template&lt;typename functor &gt; </td></tr>
<tr class="memitem:ga8208e83e1cb49d6b7ca62d94e7a62ad0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga8208e83e1cb49d6b7ca62d94e7a62ad0">Cube&lt; eT &gt;::transform</a> (functor F)</td></tr>
<tr class="memdesc:ga8208e83e1cb49d6b7ca62d94e7a62ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform each element in the cube using a functor <br/></td></tr>
<tr class="separator:ga8208e83e1cb49d6b7ca62d94e7a62ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ca822c443f626c73d9d172ce46518d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga94ca822c443f626c73d9d172ce46518d"></a>
template&lt;typename functor &gt; </td></tr>
<tr class="memitem:ga94ca822c443f626c73d9d172ce46518d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga94ca822c443f626c73d9d172ce46518d">Cube&lt; eT &gt;::imbue</a> (functor F)</td></tr>
<tr class="memdesc:ga94ca822c443f626c73d9d172ce46518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">imbue (fill) the cube with values provided by a functor <br/></td></tr>
<tr class="separator:ga94ca822c443f626c73d9d172ce46518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba21b828e6e645d32be852c7189a21ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba21b828e6e645d32be852c7189a21ad"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaba21b828e6e645d32be852c7189a21ad">Cube&lt; eT &gt;::fill</a> (const eT val)</td></tr>
<tr class="memdesc:gaba21b828e6e645d32be852c7189a21ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the cube with the specified value <br/></td></tr>
<tr class="separator:gaba21b828e6e645d32be852c7189a21ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d7814c30544a7a5cc7af72874aa1ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97d7814c30544a7a5cc7af72874aa1ba"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::zeros</b> ()</td></tr>
<tr class="separator:ga97d7814c30544a7a5cc7af72874aa1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66be0b4562b44bc7efa4e18785e7f425"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66be0b4562b44bc7efa4e18785e7f425"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::zeros</b> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:ga66be0b4562b44bc7efa4e18785e7f425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0950350d07b9766d8bda6f3dca850bf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0950350d07b9766d8bda6f3dca850bf1"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::ones</b> ()</td></tr>
<tr class="separator:ga0950350d07b9766d8bda6f3dca850bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1057a5f3edc34f4eb22305525008dee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1057a5f3edc34f4eb22305525008dee7"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::ones</b> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:ga1057a5f3edc34f4eb22305525008dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a44313f904be7e4b41b89b1cd9e2993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a44313f904be7e4b41b89b1cd9e2993"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::randu</b> ()</td></tr>
<tr class="separator:ga3a44313f904be7e4b41b89b1cd9e2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaddd35419aad97a9014c59237a1f0a06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaddd35419aad97a9014c59237a1f0a06"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::randu</b> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:gaaddd35419aad97a9014c59237a1f0a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff692a365514d2d33c392af5d5a94f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ff692a365514d2d33c392af5d5a94f9"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::randn</b> ()</td></tr>
<tr class="separator:ga4ff692a365514d2d33c392af5d5a94f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7acf5a0cd222d5f71bf11a41ab45b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed7acf5a0cd222d5f71bf11a41ab45b8"></a>
const <a class="el" href="class_cube.html">Cube</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::randn</b> (const uword in_rows, const uword in_cols, const uword in_slices)</td></tr>
<tr class="separator:gaed7acf5a0cd222d5f71bf11a41ab45b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9b3dcaf9379fc802c0bdb8b5db4bc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba9b3dcaf9379fc802c0bdb8b5db4bc9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::reset</b> ()</td></tr>
<tr class="separator:gaba9b3dcaf9379fc802c0bdb8b5db4bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4bab9449e84685f0b4cd5be44d9f46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c4bab9449e84685f0b4cd5be44d9f46"></a>
arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::min</b> () const </td></tr>
<tr class="separator:ga6c4bab9449e84685f0b4cd5be44d9f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d62fc6964c40b0fd562ed45ccf2101"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1d62fc6964c40b0fd562ed45ccf2101"></a>
arma_warn_unused eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::max</b> () const </td></tr>
<tr class="separator:gaf1d62fc6964c40b0fd562ed45ccf2101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767e0e28cb3e79c751b54fc5370bc7e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga767e0e28cb3e79c751b54fc5370bc7e6"></a>
eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::min</b> (uword &amp;index_of_min_val) const </td></tr>
<tr class="separator:ga767e0e28cb3e79c751b54fc5370bc7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4903eac65ace529c8fe9764d383bbc16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4903eac65ace529c8fe9764d383bbc16"></a>
eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::max</b> (uword &amp;index_of_max_val) const </td></tr>
<tr class="separator:ga4903eac65ace529c8fe9764d383bbc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7addd46e234fa7297c84a95db56bb6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7addd46e234fa7297c84a95db56bb6b"></a>
eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::min</b> (uword &amp;row_of_min_val, uword &amp;col_of_min_val, uword &amp;slice_of_min_val) const </td></tr>
<tr class="separator:gab7addd46e234fa7297c84a95db56bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8204a5c2dcae35f1497fed4eb0c0be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8204a5c2dcae35f1497fed4eb0c0be7"></a>
eT&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::max</b> (uword &amp;row_of_max_val, uword &amp;col_of_max_val, uword &amp;slice_of_max_val) const </td></tr>
<tr class="separator:gac8204a5c2dcae35f1497fed4eb0c0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a648d4ca1600224245ab7d46ca47a78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a648d4ca1600224245ab7d46ca47a78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga5a648d4ca1600224245ab7d46ca47a78">Cube&lt; eT &gt;::save</a> (const std::string name, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, const bool print_status=true) const </td></tr>
<tr class="memdesc:ga5a648d4ca1600224245ab7d46ca47a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the cube to a file <br/></td></tr>
<tr class="separator:ga5a648d4ca1600224245ab7d46ca47a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cdf41945a567b41d6de50f6e28b8ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae4cdf41945a567b41d6de50f6e28b8ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gae4cdf41945a567b41d6de50f6e28b8ae">Cube&lt; eT &gt;::save</a> (std::ostream &amp;os, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, const bool print_status=true) const </td></tr>
<tr class="memdesc:gae4cdf41945a567b41d6de50f6e28b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the cube to a stream <br/></td></tr>
<tr class="separator:gae4cdf41945a567b41d6de50f6e28b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aadfc5ae5ceb50c06d358cd8e6a6167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3aadfc5ae5ceb50c06d358cd8e6a6167"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga3aadfc5ae5ceb50c06d358cd8e6a6167">Cube&lt; eT &gt;::load</a> (const std::string name, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>, const bool print_status=true)</td></tr>
<tr class="memdesc:ga3aadfc5ae5ceb50c06d358cd8e6a6167"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a cube from a file <br/></td></tr>
<tr class="separator:ga3aadfc5ae5ceb50c06d358cd8e6a6167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5fb69666d9502592187488c1aa3248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d5fb69666d9502592187488c1aa3248"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga9d5fb69666d9502592187488c1aa3248">Cube&lt; eT &gt;::load</a> (std::istream &amp;is, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>, const bool print_status=true)</td></tr>
<tr class="memdesc:ga9d5fb69666d9502592187488c1aa3248"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a cube from a stream <br/></td></tr>
<tr class="separator:ga9d5fb69666d9502592187488c1aa3248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5663f18736f1fe9accccefe0f6d15f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b5663f18736f1fe9accccefe0f6d15f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga0b5663f18736f1fe9accccefe0f6d15f">Cube&lt; eT &gt;::quiet_save</a> (const std::string name, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>) const </td></tr>
<tr class="memdesc:ga0b5663f18736f1fe9accccefe0f6d15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the cube to a file, without printing any error messages <br/></td></tr>
<tr class="separator:ga0b5663f18736f1fe9accccefe0f6d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3480aab4000db1e3e844b5bb1e75d79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3480aab4000db1e3e844b5bb1e75d79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gab3480aab4000db1e3e844b5bb1e75d79">Cube&lt; eT &gt;::quiet_save</a> (std::ostream &amp;os, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>) const </td></tr>
<tr class="memdesc:gab3480aab4000db1e3e844b5bb1e75d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">save the cube to a stream, without printing any error messages <br/></td></tr>
<tr class="separator:gab3480aab4000db1e3e844b5bb1e75d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa9fc020fb7eb63d7f17966d77b1397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6aa9fc020fb7eb63d7f17966d77b1397"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6aa9fc020fb7eb63d7f17966d77b1397">Cube&lt; eT &gt;::quiet_load</a> (const std::string name, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>)</td></tr>
<tr class="memdesc:ga6aa9fc020fb7eb63d7f17966d77b1397"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a cube from a file, without printing any error messages <br/></td></tr>
<tr class="separator:ga6aa9fc020fb7eb63d7f17966d77b1397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf397928506b2295bdf4102447c9dc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadbf397928506b2295bdf4102447c9dc9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gadbf397928506b2295bdf4102447c9dc9">Cube&lt; eT &gt;::quiet_load</a> (std::istream &amp;is, const <a class="el" href="group__diskio.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=<a class="el" href="group__diskio.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>)</td></tr>
<tr class="memdesc:gadbf397928506b2295bdf4102447c9dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a cube from a stream, without printing any error messages <br/></td></tr>
<tr class="separator:gadbf397928506b2295bdf4102447c9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d792e0db06c3345152c0fb88dd15d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7d792e0db06c3345152c0fb88dd15d1"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::begin</b> ()</td></tr>
<tr class="separator:gaa7d792e0db06c3345152c0fb88dd15d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc073fb73fecb1a8a427082dbeb34b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7cc073fb73fecb1a8a427082dbeb34b9"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::begin</b> () const </td></tr>
<tr class="separator:ga7cc073fb73fecb1a8a427082dbeb34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cab55656fa347f3914d9aca2e8f4d79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cab55656fa347f3914d9aca2e8f4d79"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::end</b> ()</td></tr>
<tr class="separator:ga9cab55656fa347f3914d9aca2e8f4d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d83b2e9363939cabff2ee2f9101663c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d83b2e9363939cabff2ee2f9101663c"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::end</b> () const </td></tr>
<tr class="separator:ga0d83b2e9363939cabff2ee2f9101663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae630381ffdc61c8782f77bc46d29c779"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae630381ffdc61c8782f77bc46d29c779"></a>
slice_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::begin_slice</b> (const uword slice_num)</td></tr>
<tr class="separator:gae630381ffdc61c8782f77bc46d29c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaefa910465305a02ebf59f282581dcef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaefa910465305a02ebf59f282581dcef"></a>
const_slice_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::begin_slice</b> (const uword slice_num) const </td></tr>
<tr class="separator:gaaefa910465305a02ebf59f282581dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0583f51385b99f9d1f968dbd8fe99c88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0583f51385b99f9d1f968dbd8fe99c88"></a>
slice_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::end_slice</b> (const uword slice_num)</td></tr>
<tr class="separator:ga0583f51385b99f9d1f968dbd8fe99c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7737b2904aec585124674ca0d99a56d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7737b2904aec585124674ca0d99a56d"></a>
const_slice_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Cube&lt; eT &gt;::end_slice</b> (const uword slice_num) const </td></tr>
<tr class="separator:gad7737b2904aec585124674ca0d99a56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711b4f9e03c78ea34b759a8c5a4f8226"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga711b4f9e03c78ea34b759a8c5a4f8226"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga711b4f9e03c78ea34b759a8c5a4f8226">Cube&lt; eT &gt;::clear</a> ()</td></tr>
<tr class="memdesc:ga711b4f9e03c78ea34b759a8c5a4f8226"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets this cube to an empty matrix <br/></td></tr>
<tr class="separator:ga711b4f9e03c78ea34b759a8c5a4f8226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed671ee8806de5a3090ad9a52b505a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed671ee8806de5a3090ad9a52b505a46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gaed671ee8806de5a3090ad9a52b505a46">Cube&lt; eT &gt;::empty</a> () const </td></tr>
<tr class="memdesc:gaed671ee8806de5a3090ad9a52b505a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the cube has no elements <br/></td></tr>
<tr class="separator:gaed671ee8806de5a3090ad9a52b505a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce8cc998a93beb0432adc3465c53c91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacce8cc998a93beb0432adc3465c53c91"></a>
uword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#gacce8cc998a93beb0432adc3465c53c91">Cube&lt; eT &gt;::size</a> () const </td></tr>
<tr class="memdesc:gacce8cc998a93beb0432adc3465c53c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of elements in this cube <br/></td></tr>
<tr class="separator:gacce8cc998a93beb0432adc3465c53c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cube.html#ga70006d5a49f67d35d4ae10cb6c5a681f">Cube&lt; eT &gt;::steal_mem</a> (<a class="el" href="class_cube.html">Cube</a> &amp;X)</td></tr>
<tr class="memdesc:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't use this unless you're writing code internal to Armadillo  <a href="#ga70006d5a49f67d35d4ae10cb6c5a681f"></a><br/></td></tr>
<tr class="separator:ga70006d5a49f67d35d4ae10cb6c5a681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab817654b89cd4091fd61376a74654ecb"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab817654b89cd4091fd61376a74654ecb"></a>
template&lt;typename eT &gt; </td></tr>
<tr class="memitem:gab817654b89cd4091fd61376a74654ecb"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gab817654b89cd4091fd61376a74654ecb">Cube_aux::prefix_pp</a> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr class="memdesc:gab817654b89cd4091fd61376a74654ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix ++ <br/></td></tr>
<tr class="separator:gab817654b89cd4091fd61376a74654ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74560f4801a21b90148f9a0c22bbbfe6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga74560f4801a21b90148f9a0c22bbbfe6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga74560f4801a21b90148f9a0c22bbbfe6"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga74560f4801a21b90148f9a0c22bbbfe6">Cube_aux::prefix_pp</a> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ga74560f4801a21b90148f9a0c22bbbfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix ++ for complex numbers (work around for limitations of the std::complex class) <br/></td></tr>
<tr class="separator:ga74560f4801a21b90148f9a0c22bbbfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902de64c8363b4e38fe1fd221589ad85"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga902de64c8363b4e38fe1fd221589ad85"></a>
template&lt;typename eT &gt; </td></tr>
<tr class="memitem:ga902de64c8363b4e38fe1fd221589ad85"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga902de64c8363b4e38fe1fd221589ad85">Cube_aux::postfix_pp</a> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr class="memdesc:ga902de64c8363b4e38fe1fd221589ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix ++ <br/></td></tr>
<tr class="separator:ga902de64c8363b4e38fe1fd221589ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7faa33fadba773dfe4ee43f4a2f62da9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7faa33fadba773dfe4ee43f4a2f62da9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7faa33fadba773dfe4ee43f4a2f62da9"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga7faa33fadba773dfe4ee43f4a2f62da9">Cube_aux::postfix_pp</a> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ga7faa33fadba773dfe4ee43f4a2f62da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix ++ for complex numbers (work around for limitations of the std::complex class) <br/></td></tr>
<tr class="separator:ga7faa33fadba773dfe4ee43f4a2f62da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b025c5e0deb99b2bf5b5f1b1d479735"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6b025c5e0deb99b2bf5b5f1b1d479735"></a>
template&lt;typename eT &gt; </td></tr>
<tr class="memitem:ga6b025c5e0deb99b2bf5b5f1b1d479735"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6b025c5e0deb99b2bf5b5f1b1d479735">Cube_aux::prefix_mm</a> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6b025c5e0deb99b2bf5b5f1b1d479735"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix &ndash; <br/></td></tr>
<tr class="separator:ga6b025c5e0deb99b2bf5b5f1b1d479735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1279d906a8fe4f930eb42d1352d1ab70"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1279d906a8fe4f930eb42d1352d1ab70"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1279d906a8fe4f930eb42d1352d1ab70"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga1279d906a8fe4f930eb42d1352d1ab70">Cube_aux::prefix_mm</a> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ga1279d906a8fe4f930eb42d1352d1ab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix &ndash; for complex numbers (work around for limitations of the std::complex class) <br/></td></tr>
<tr class="separator:ga1279d906a8fe4f930eb42d1352d1ab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbad6f993f5fb786102f69528e18f4c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="gacbad6f993f5fb786102f69528e18f4c2"></a>
template&lt;typename eT &gt; </td></tr>
<tr class="memitem:gacbad6f993f5fb786102f69528e18f4c2"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#gacbad6f993f5fb786102f69528e18f4c2">Cube_aux::postfix_mm</a> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr class="memdesc:gacbad6f993f5fb786102f69528e18f4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix &ndash; <br/></td></tr>
<tr class="separator:gacbad6f993f5fb786102f69528e18f4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab48de0f28ac87204b1e2fde5a58709"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6ab48de0f28ac87204b1e2fde5a58709"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6ab48de0f28ac87204b1e2fde5a58709"><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___cube.html#ga6ab48de0f28ac87204b1e2fde5a58709">Cube_aux::postfix_mm</a> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6ab48de0f28ac87204b1e2fde5a58709"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix ++ for complex numbers (work around for limitations of the std::complex class) <br/></td></tr>
<tr class="separator:ga6ab48de0f28ac87204b1e2fde5a58709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767aa09578088dc408d3b6d5a91523a3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga767aa09578088dc408d3b6d5a91523a3"></a>
template&lt;typename eT , typename T1 &gt; </td></tr>
<tr class="memitem:ga767aa09578088dc408d3b6d5a91523a3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube_aux::set_real</b> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;out, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;X)</td></tr>
<tr class="separator:ga767aa09578088dc408d3b6d5a91523a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c051245bf5ffdfd28bf81d7f69976e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4c051245bf5ffdfd28bf81d7f69976e9"></a>
template&lt;typename eT , typename T1 &gt; </td></tr>
<tr class="memitem:ga4c051245bf5ffdfd28bf81d7f69976e9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube_aux::set_imag</b> (<a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;out, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;X)</td></tr>
<tr class="separator:ga4c051245bf5ffdfd28bf81d7f69976e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5c2cc8de7ff4b4123995b6b8c364db"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b5c2cc8de7ff4b4123995b6b8c364db"></a>
template&lt;typename T , typename T1 &gt; </td></tr>
<tr class="memitem:ga1b5c2cc8de7ff4b4123995b6b8c364db"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube_aux::set_real</b> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;out, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; T, T1 &gt; &amp;X)</td></tr>
<tr class="separator:ga1b5c2cc8de7ff4b4123995b6b8c364db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac863a65906043d42d7051848cca27e10"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac863a65906043d42d7051848cca27e10"></a>
template&lt;typename T , typename T1 &gt; </td></tr>
<tr class="memitem:gac863a65906043d42d7051848cca27e10"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cube_aux::set_imag</b> (<a class="el" href="class_cube.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;out, const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; T, T1 &gt; &amp;X)</td></tr>
<tr class="separator:gac863a65906043d42d7051848cca27e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7ab7e9933fa8e895918e59cdde8a5b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="class_cube.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">eT *&#160;</td>
          <td class="paramname"><em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_aux_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct a cube from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). note that in the latter case the default is to copy the array. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga7ab7e9933fa8e895918e59cdde8a5b30_cgraph.png" border="0" usemap="#group___cube_ga7ab7e9933fa8e895918e59cdde8a5b30_cgraph" alt=""/></div>
<!-- MAP 1 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7ab7e9933fa8e895918e59cdde8a5b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="class_cube.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">eT *&#160;</td>
          <td class="paramname"><em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_aux_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct a cube from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). note that in the latter case the default is to copy the array. </p>

</div>
</div>
<a class="anchor" id="gac9a5268589f8e171a9ff405d2746e52b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="class_cube.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const eT *&#160;</td>
          <td class="paramname"><em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct a cube from a given auxiliary read-only array of eTs. the array is copied. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_gac9a5268589f8e171a9ff405d2746e52b_cgraph.png" border="0" usemap="#group___cube_gac9a5268589f8e171a9ff405d2746e52b_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="gac9a5268589f8e171a9ff405d2746e52b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="class_cube.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const eT *&#160;</td>
          <td class="paramname"><em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>aux_n_slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>construct a cube from a given auxiliary read-only array of eTs. the array is copied. </p>

</div>
</div>
<a class="anchor" id="gac9b2d2e78a972c809049bc4a093298b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's state are restored to their original values. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_gac9b2d2e78a972c809049bc4a093298b7_cgraph.png" border="0" usemap="#group___cube_gac9b2d2e78a972c809049bc4a093298b7_cgraph" alt=""/></div>
<!-- MAP 3 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="gac9b2d2e78a972c809049bc4a093298b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's state are restored to their original values. </p>

</div>
</div>
<a class="anchor" id="ga5c4412ed27ad094df35a143cd77864fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's state are restored to their original values. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga5c4412ed27ad094df35a143cd77864fe_cgraph.png" border="0" usemap="#group___cube_ga5c4412ed27ad094df35a143cd77864fe_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga5c4412ed27ad094df35a143cd77864fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's state are restored to their original values. </p>

</div>
</div>
<a class="anchor" id="gabbdee61973e0e18bec6cb0a67f141dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_raw_print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the stream's state are used as is and are not modified (i.e. the precision and cell width are not modified). </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_gabbdee61973e0e18bec6cb0a67f141dad_cgraph.png" border="0" usemap="#group___cube_gabbdee61973e0e18bec6cb0a67f141dad_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="gabbdee61973e0e18bec6cb0a67f141dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_raw_print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the stream's state are used as is and are not modified (i.e. the precision and cell width are not modified). </p>

</div>
</div>
<a class="anchor" id="gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_raw_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the stream's state are used as is and are not modified. (i.e. the precision and cell width are not modified). </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19_cgraph.png" border="0" usemap="#group___cube_gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="gad9cb4ecfd6bc0b4cc2ae27d9b1af5c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::impl_raw_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extra_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the stream's state are used as is and are not modified. (i.e. the precision and cell width are not modified). </p>

</div>
</div>
<a class="anchor" id="ga0bac41399b3c1d815c20e540032bfe5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarma_1_1_cube.html">arma::Cube</a>&lt; eT &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma_1_1_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="classarma_1_1_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="group__mt_sp_op.html#ga66319587c3b2a08f80e4612e7577ba7c">pod_type</a>, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma_1_1_base_cube.html">BaseCube</a>&lt; typename <a class="el" href="classarma_1_1_cube.html">Cube</a>&lt; eT &gt;::<a class="el" href="group__mt_sp_op.html#ga66319587c3b2a08f80e4612e7577ba7c">pod_type</a>, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for constructing a complex cube out of two non-complex cubes </p>
<p>&lt; compile-time abort if eT isn't std::complex</p>
<p>&lt; compile-time abort if T is std::complex</p>
<p>&lt; compile-time abort if types are not compatible </p>

</div>
</div>
<a class="anchor" id="ga8a1689ab31561d9ffcbf09f00f5e3965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::init_warm </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>internal cube construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new' </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga8a1689ab31561d9ffcbf09f00f5e3965_cgraph.png" border="0" usemap="#group___cube_ga8a1689ab31561d9ffcbf09f00f5e3965_cgraph" alt=""/></div>
<!-- MAP 7 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga8a1689ab31561d9ffcbf09f00f5e3965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::init_warm </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>in_n_slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>internal cube construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new' </p>

</div>
</div>
<a class="anchor" id="gaf078433be12abde746651319f32d0549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::insert_slices </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>set_to_zero</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert N slices at the specified slice position, optionally setting the elements of the inserted slices to zero </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_gaf078433be12abde746651319f32d0549_cgraph.png" border="0" usemap="#group___cube_gaf078433be12abde746651319f32d0549_cgraph" alt=""/></div>
<!-- MAP 8 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="gaf078433be12abde746651319f32d0549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::insert_slices </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>set_to_zero</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert N slices at the specified slice position, optionally setting the elements of the inserted slices to zero </p>

</div>
</div>
<a class="anchor" id="ga91d16fa2835700a338e87bc5dc9ce8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::insert_slices </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert the given object at the specified slice position; the given object must have the same number of rows and columns as the cube </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga91d16fa2835700a338e87bc5dc9ce8fd_cgraph.png" border="0" usemap="#group___cube_ga91d16fa2835700a338e87bc5dc9ce8fd_cgraph" alt=""/></div>
<!-- MAP 9 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga91d16fa2835700a338e87bc5dc9ce8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::insert_slices </td>
          <td>(</td>
          <td class="paramtype">const uword&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma_1_1_base_cube.html">BaseCube</a>&lt; eT, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert the given object at the specified slice position; the given object must have the same number of rows and columns as the cube </p>

</div>
</div>
<a class="anchor" id="ga73fd2fa4151f5bd8dab023d73c8731ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const eT&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the cube to be equal to the specified scalar. NOTE: the size of the cube will be 1x1x1 </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga73fd2fa4151f5bd8dab023d73c8731ba_cgraph.png" border="0" usemap="#group___cube_ga73fd2fa4151f5bd8dab023d73c8731ba_cgraph" alt=""/></div>
<!-- MAP 10 -->
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga73fd2fa4151f5bd8dab023d73c8731ba_icgraph.png" border="0" usemap="#group___cube_ga73fd2fa4151f5bd8dab023d73c8731ba_icgraph" alt=""/></div>
<!-- MAP 11 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga73fd2fa4151f5bd8dab023d73c8731ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const eT&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the cube to be equal to the specified scalar. NOTE: the size of the cube will be 1x1x1 </p>

</div>
</div>
<a class="anchor" id="ga70006d5a49f67d35d4ae10cb6c5a681f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::steal_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cube.html">Cube</a>&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>don't use this unless you're writing code internal to Armadillo </p>
<p>try to steal the memory from a given cube; if memory can't be stolen, copy the given cube </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___cube_ga70006d5a49f67d35d4ae10cb6c5a681f_cgraph.png" border="0" usemap="#group___cube_ga70006d5a49f67d35d4ae10cb6c5a681f_cgraph" alt=""/></div>
<!-- MAP 12 -->
</div>
</p>

</div>
</div>
<a class="anchor" id="ga70006d5a49f67d35d4ae10cb6c5a681f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cube.html">Cube</a>&lt; eT &gt;::steal_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarma_1_1_cube.html">Cube</a>&lt; eT &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>don't use this unless you're writing code internal to Armadillo </p>
<p>try to steal the memory from a given cube; if memory can't be stolen, copy the given cube </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Aug 22 2013 19:51:19 for oFreq by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
